#!/usr/bin/perl
# cpeval2 - Performs a pre-migration evaluation of third-party and cPanel servers
# See COPYRIGHT section in pod_data below or run 'perldoc' on this file for copyright and license information.

use strict;
use warnings;

my $pod_data = << 'END_POD';
=head1 NAME

cpeval2

=head1 DESCRIPTION

Checks account and configuration information on third-party (non-cPanel) source and cPanel destination servers, performs a configuration comparison, and outputs a form ready for sending to a customer to explain any required or recommended changes.

=head1 SYNOPSIS

=for comment
Keep the usage() sub in sync with the options here.
=end comment

=over

=item Mode 1:

B<cpeval2>

=back

=over

=item Mode 2:

B<cpeval2> S<I<INPUTFILE>>

B<cpeval2> S<B<--es> I<INPUTFILE>>

=back

=over

=item Other:

B<cpeval2> S<B<--cpanel-source>>

B<cpeval2> S<B<--create-keys>>

B<cpeval2> S<B<--updateuserdomains>>

B<cpeval2> S<B<--full-help>>

=back

=head1 DEFINITIONS

=over

=item C<INPUTFILE>

An input file is a text file containing cpeval2 prefixed output from "Mode 1" on both source and destination servers, concatenated into a single file.  The prefixed output begins with "s:" for the source server, and "d:" for the destination server.

=back

=head1 FLAGS

=over

=item B<--cpanel-source>

Necessary to run cpeval2 in "Mode 1" on a cPanel source server.  Without this flag cpeval2 assumes that a cPanel server is the destination.

=item B<--create-keys>

For use only on a destination (cPanel) server.  Creates a unique SSH key-pair to be used for a dedicated migration user account on the source server, and provides copy/paste output that can be executed on the source server to create the account.  It is automatically used the first time you run cpeval2 on a cPanel server.

=item B<--updateuserdomains>

For use only on a third-party source (non-cPanel) server.  Downloads and executes the updateuserdomains-universal script to populate /etc/trueuserdomains.  It is automatically used if /etc/trueuserdomains is more than 30 minutes old or does not exist.

=item B<--es>

For use only with "Mode 2", this provides output in Spanish.

=back

=head1 EXAMPLES

=over

=item Run cpeval2 for the first time on a third-party source or cPanel destination server (Mode 1):

B<cpeval2>

=item Run cpeval2 for the first time on a cPanel source server (Mode 1):

B<cpeval2 --cpanel-source>

=item Run cpeval2 after "Mode 1" prefixed output from both servers has been copied into "cpeval2-compare.txt":

B<cpeval2 cpeval2-compare.txt>

=item Run cpeval2 after "Mode 1" prefixed output from both servers has been copied into "cpeval2-compare.txt", and provide the output in Spanish:

B<cpeval2 --es cpeval2-compare.txt>

=item Download and run the updateuserdomains-universal script:

B<cpeval2 --updateuserdomains>

=back

=head1 COPYRIGHT

This software is Copyright 2017 by cPanel, Inc.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THE SOFTWARE LICENSED HEREUNDER IS PROVIDED "AS IS" AND CPANEL HEREBY DISCLAIMS ALL WARRANTIES OF ANY KIND, WHETHER EXPRESS OR IMPLIED, RELATING TO THE SOFTWARE, ITS THIRD PARTY COMPONENTS, AND ANY DATA ACCESSED THEREFROM, OR THE ACCURACY, TIMELINESS, COMPLETENESS, OR ADEQUACY OF THE SOFTWARE, ITS THIRD PARTY COMPONENTS, AND ANY DATA ACCESSED THEREFROM, INCLUDING THE IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT. CPANEL DOES NOT WARRANT THAT THE SOFTWARE OR ITS THIRD PARTY COMPONENTS ARE ERROR-FREE OR WILL OPERATE WITHOUT INTERRUPTION. IF THE SOFTWARE, ITS THIRD PARTY COMPONENTS, OR ANY DATA ACCESSED THEREFROM IS DEFECTIVE, YOU ASSUME THE SOLE RESPONSIBILITY FOR THE ENTIRE COST OF ALL REPAIR OR INJURY OF ANY KIND, EVEN IF CPANEL HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DEFECTS OR DAMAGES. NO ORAL OR WRITTEN INFORMATION OR ADVICE GIVEN BY CPANEL, ITS AFFILIATES, LICENSEES, DEALERS, SUB-LICENSORS, AGENTS OR EMPLOYEES SHALL CREATE A WARRANTY OR IN ANY WAY INCREASE THE SCOPE OF ANY WARRANTY.

=cut
END_POD

# ADDING CHECKS
# There are 4 things that need to be done. Using the PHP check as an example:

# When run WITHOUT an input file (e.g., lwp-request x.x.x.x/cpeval2 | perl):

# (1) print_php_info()            # prints PHP: 5.3.24
# (2) print_prefixed_php_info()   # prints s:Ensim:PHP:5.1

# When run WITH an input file (e.g., ./cpeval2 outfile):

# (3) parse_output_file()
# (4) print_parsed_php_info( $src_php, $dst_php )

use Getopt::Long;
use IPC::Open3;
use IO::Socket::INET;
use Pod::Usage;
use POSIX qw( strftime );
use Term::ANSIColor qw(:constants);
$Term::ANSIColor::AUTORESET = 1;

my $VERSION = '1.38';

my $OPTS = opts_get();

create_cpmig_user() if $OPTS->{'createuser'};

my $DEBUG = 0;

my $PANEL_REGEX = 's:(?:cPanel|Plesk[0-9]+(?:SMB)?|Ensim|DirectAdmin)';

my $PREFIX;    # d: or s:Plesk9 or s:DirectAdmin, etc.
my $APACHE_BIN;
my $PYTHON_BIN;

my $IS_CPANEL        = 0;
my $IS_CPANEL_DEST   = 0;
my $IS_CPANEL_SOURCE = 0;
my $IS_PLESK         = 0;
my $IS_PLESK_SMB10   = 0;
my $IS_ENSIM         = 0;
my $IS_DA            = 0;

my $SRC_PANEL;              # cPanel, Ensim, DirectAdmin, Plesk8, Plesk10SMB, etc.
my $SRC_PANEL_NOVERSION;    # cPanel, Ensim, DirectAdmin, Plesk
my $SRC_PANEL_VERSION;      # e.g. "Plesk 12.0.18"

my $DST_PANEL_VERSION;      # e.g. "cPanel 11.44.0.18"

my $CPANEL_VERSION;         # e.g. "11.44.0.18"
my $OS_DIST;                # e.g. "CentOS"
my $OS_VERSION;             # e.g. "7.2"

my ( @HOSTING_TYPE_FORWARD, @HOSTING_TYPE_NOHOSTING );
my @PLESK_RESELLER_USERNAME_CONFLICTS;

my $HAS_PGSQL     = 0;
my $EULA_ACCEPTED = 0;

my ( $PLESK_MAJOR_VERSION, $PLESK_MINOR_VERSION );

my @BADUSERS;               # if mysql username conflicts are detected, skip any bad users since they need renaming anyway

my $TUD_BY_USER;
my $TUD_BY_DOMAIN;
my $TUD_USER_NUM = 0;

get_control_panel_and_set_prefix();
verify_mysql_connectivity();

my $TICKET    = get_ticket();
my $CPMIGUSER = 'cpmig' . $TICKET;

if ( $OPTS->{'createkeys'} ) {
    die "create-keys should only be run on the cPanel destination host.\n" unless $IS_CPANEL_DEST;
    create_cpmig_keypair( $CPMIGUSER, $TICKET );
    exit;
}

if ( $OPTS->{'updateuserdomains'} ) {
    die "cpeval2 --updateuserdomains is only for non-cPanel servers.\nUse /scripts/updateuserdomains instead.\n" if $IS_CPANEL;
}

## behave like the original cpeval
if ( !$OPTS->{'inputfile'} ) {
    ( $TUD_BY_USER, $TUD_BY_DOMAIN ) = _get_trueuserdomains_hashrefs();
    $TUD_USER_NUM = scalar keys %{$TUD_BY_USER};
    print_control_panel_info();
    print_os_info();
    print_perl_info();
    print_mysql_info();
    print_php_info();
    print_apache_info();
    print_cpu_info();
    print_mem_info();
    print_number_of_accounts();
    print_dedicated_ipaddrs();
    print_mysql_db_count();
    print_postgres_db_count();
    check_destination_var_usage();
    print_custom_apache_modules();
    print_custom_php_modules();
    print_htype_fwd();
    print_htype_none();
    print_plesk_duplicate_email_users();
    print_reseller_username_conflicts();

    print "\n" . '-' x 40 . "\n\n";

    print_prefixed_panel_info();
    print_prefixed_os_info();
    print_prefixed_php_info();
    print_prefixed_mysql_info();
    print_prefixed_bad_username_info();    # this sub MUST come before print_mysql_username_conflict_info();
    print_prefixed_duplicate_users();
    print_prefixed_dedicated_ip_addr_info();
    print_prefixed_hosting_types();
    print_prefixed_tomcat_info();
    print_prefixed_coldfusion_info();
    print_prefixed_reseller_username_conflicts();
    print_prefixed_user_config_problems();
    print_prefixed_php_information();
    print_prefixed_cpanel_eula_accepted_check();
    print_prefixed_mysql_username_conflict_info();
    print_prefixed_mysql_openfileslimit();
    print_prefixed_mysql_skip_networking();
    print_prefixed_mysql_old_style_passwords_info();
    print_prefixed_dns_clustering_info();

}
## parse output file; this prints info we can just copy/paste into the ticket
else {
    parse_output_file( $OPTS->{'inputfile'} );
}

unless ( $OPTS->{'inputfile'} ) {
    print_header('DISK SPACE');
    print "Please review this output now, compare with the output from the other server, and check for possible issues:\n\n";
    print `df -Ph | column -t | head -1 ; df -Ph | column -t | sort | uniq | egrep -v '^Filesystem|/var/named/run-root/var/run/dbus|/var/named/chroot|/usr/local/psa/handlers/|/virtfs/| /tmp\$'`;
    print "\nA few things to keep in mind are:\n";
    print "  * pkgacct-* packages accounts in /home . Is /home on /, or is it separate?\n";
    print "  * Need to change the partition that accounts are packaged to? Check the 'MigrationsReference' article\n";
    print "  * Is more space being used on the source than what is available on the destination?\n";
    print "  * If there's, say, 50GB free on the source, the largest account that can be copied is a little less than 25GB (half of 50)\n";

    if ($IS_PLESK) {
        print "  * Plesk stores users' data under /var [ /var/www/vhosts/\${DOMAIN}/ ] [ /var/qmail/mailnames/\${DOMAIN}/ ] [ /var/lib/mysql ]\n";
        if ( $^O =~ /freebsd/i ) {
            print "  * commonly, customers with FreeBSD will have different locations for their services\n"
              . "  * if pkgacct fails to find the locations of the user's data, you will need to get the locations of the data from /etc/psa/psa.conf, then create directories and symlinks so pkgacct can package correctly\n"
              . "  * variables to grep for in the psa.conf are HTTPD_VHOSTS_D, QMAIL_MAILNAMES_D, MYSQL_VAR_D, PGSQL_DATA_D\n";
        }
    }
}

if ( $IS_CPANEL_DEST and -f '/var/cpanel/transfers_devel' ) {
    print "\n\n!! /var/cpanel/transfers_devel exists! Server may be using _DEVEL migrations scripts !!\n";
}

submit_stats_info();

check_for_missing_scp();

auto_create_keypair( $CPMIGUSER, $TICKET ) unless $OPTS->{'inputfile'};

print_dest_existing_accounts();

print "\n";

exit 0;

##########

sub _version_cmp {
    ## no critic (AmbiguousNames) # Not ambiguous, just simple.
    my ( $first, $second ) = @_;
    my ( $a1, $b1, $c1, $d1 ) = split /[\._]/, $first;
    my ( $a2, $b2, $c2, $d2 ) = split /[\._]/, $second;
    for my $ref ( \$a1, \$b1, \$c1, \$d1, \$a2, \$b2, \$c2, \$d2, ) {    # Fill empties with 0
        $$ref = 0 unless defined $$ref;
    }
    return $a1 <=> $a2 || $b1 <=> $b2 || $c1 <=> $c2 || $d1 <=> $d2;
}

sub version_compare {

    # example: return if version_compare($ver_string, qw( >= 1.2.3.3 ));
    # Must be no more than four version numbers separated by periods and/or underscores.
    my ( $ver1, $mode, $ver2 ) = @_;
    return if ( !defined($ver1) || ( $ver1 =~ /[^\._0-9]/ ) );
    return if ( !defined($ver2) || ( $ver2 =~ /[^\._0-9]/ ) );

    # Shamelessly copied the comparison logic out of Cpanel::Version::Compare
    my %modes = (
        '>' => sub {
            return if $_[0] eq $_[1];
            return _version_cmp(@_) > 0;
        },
        '<' => sub {
            return if $_[0] eq $_[1];
            return _version_cmp(@_) < 0;
        },
        '==' => sub { return $_[0] eq $_[1] || _version_cmp(@_) == 0; },
        '!=' => sub { return $_[0] ne $_[1] && _version_cmp(@_) != 0; },
        '>=' => sub {
            return 1 if $_[0] eq $_[1];
            return _version_cmp(@_) >= 0;
        },
        '<=' => sub {
            return 1 if $_[0] eq $_[1];
            return _version_cmp(@_) <= 0;
        }
    );
    return if ( !exists $modes{$mode} );
    return $modes{$mode}->( $ver1, $ver2 );
}

sub print_news_cpanel {
    print q{};
    return;
}

sub print_news_plesk {

    #    print q{   !! PLESK BLOCKERS !!
    #    };
    #
    #    sleep 3;
    return;
}

sub print_news_ensim {

    # No current blockers listed.  Last removed was Case 107517.
    return;
}

sub print_news_da {

    #    print q{   !! DA BLOCKERS !!
    #    };
    #
    #    sleep 3;
    return;
}

sub mysql_test {
    my $mysql_output = `mysql -e 'select 1' 2>&1`;
    return $mysql_output;
}

sub print_header {
    my $text = shift;
    print "\n\n" . '=' x 50 . "\n$text\n" . '=' x 50 . "\n\n";
    return;
}

## determine the control panel, and set the prefix
sub get_control_panel_and_set_prefix {    ## no critic (ExcessComplexity)

    # CPANEL
    if ( -f '/usr/local/cpanel/cpanel' ) {    ## no critic (CascadingIfElse)
        $IS_CPANEL = 1;
        if ( $OPTS->{'cpanelsource'} ) {
            $PREFIX           = 's:cPanel:';
            $IS_CPANEL_SOURCE = 1;
        }
        else {
            $PREFIX         = 'd:';
            $IS_CPANEL_DEST = 1;
        }
    }

    # PLESK
    elsif ( -f '/usr/local/psa/version' ) {
        if ( -d '/etc/sw/keys/keys' ) {
            my @dir_contents;

            opendir( my $dir_fh, '/etc/sw/keys/keys' );
            @dir_contents = grep { !/ \A \. \.? \Z /x } readdir $dir_fh;
            closedir $dir_fh;

            if (@dir_contents) {
                my $plesk_key = pop @dir_contents;

                if ( open my $key_fh, '<', "/etc/sw/keys/keys/$plesk_key" ) {
                    while (<$key_fh>) {
                        if (/PPA\./) {
                            die("We're very sorry, but this appears to be a Plesk Automation (PPA) server which is not supported for migration.\n");
                        }
                        if (/Small Business Panel 10/) {
                            $PREFIX         = 's:Plesk10SMB:';
                            $IS_PLESK_SMB10 = 1;
                            last;
                        }
                    }
                    close $key_fh;
                }
            }
        }

        if ( !$PREFIX ) {
            if ( open my $psa_fh, '<', '/usr/local/psa/version' ) {
                while (<$psa_fh>) {
                    if (m{ \A (\d+)\.(\d+)? }xms) {
                        $PLESK_MAJOR_VERSION = $1;
                        $PLESK_MINOR_VERSION = defined $2 ? $2 : '0';
                        if ( $PLESK_MAJOR_VERSION == 11 and $PLESK_MINOR_VERSION and $PLESK_MINOR_VERSION >= 5 ) {

                            #                        print_plesk_version_unsupported( "${plesk_major_version}.${plesk_minor_version}" );
                        }

                        $PREFIX   = 's:Plesk' . $PLESK_MAJOR_VERSION . ':';
                        $IS_PLESK = 1;
                    }
                }
                close $psa_fh;
            }
        }
    }

    # ENSIM
    elsif ( -f '/usr/bin/getapplversion' ) {
        $PREFIX   = 's:Ensim:';
        $IS_ENSIM = 1;
    }

    # DA
    elsif ( -f '/usr/local/directadmin/directadmin' ) {
        $PREFIX = 's:DirectAdmin:';
        $IS_DA  = 1;
    }

    # Not one of the above
    else {
        die "[!] Unknown control panel\n";
    }

    print_news_cpanel() if ($IS_CPANEL);
    print_news_plesk()  if ( $IS_PLESK or $IS_PLESK_SMB10 );
    print_news_ensim()  if ($IS_ENSIM);
    print_news_da()     if ($IS_DA);
    return;
}

sub check_trueuserdomains {
    my $tud         = '/etc/trueuserdomains';
    my $dip         = '/etc/domainips';
    my $uudu        = 'http://httpupdate.cpanel.net/cpanelsync/transfers_PUBLIC/pkgacct/updateuserdomains-universal';
    my $max_age     = 30;                                                                                               #minutes
    my $skip_update = 0;

    unless ($IS_CPANEL) {
        if ( -f $tud ) {
            my $age = int( ( time() - ( stat(_) )[9] ) / 60 );
            die("${tud} exists, but unable to determine modification time!\n\n") unless defined($age);
            if ( not $OPTS->{'updateuserdomains'} and $age <= $max_age ) {
                print "\n${tud} is less than ${max_age} minutes old, not auto-updating.\n";
                print "Use cpeval2 --updateuserdomains to force an update.\n";
                $skip_update = 1;
            }
        }
        if ( $OPTS->{'updateuserdomains'} or not $skip_update ) {
            print "${tud} doesn't exist, is more than ${max_age} minutes old, or you forced an update.\n";
            print "\nDownloading and running updateuserdomains-universal via curl...\n";
            delete local $ENV{'PERL5LIB'};    # Like CPANEL-18856
            if ( system( 'curl -s --connect-timeout 30 --max-time 60  ' . $uudu . ' | perl -x' ) != 0 ) {
                print "\nDownloading and running updateuserdomains-universal via wget...\n";
                if ( system( 'wget --timeout=60 -q -O - ' . $uudu . ' | perl -x' ) != 0 ) {
                    print "\nFailed to download and run updateuserdomains-universal!\n";
                    sleep 2;
                }
            }
        }
    }
    unless ($IS_CPANEL_DEST) {
        if ( -f $tud and -z _ ) {
            die "\n${tud} exists, but is empty!\n\n";
        }
        if ( not -f $tud or not -f $dip ) {
            die "\n${tud} OR ${dip} missing!\nUse updateuserdomains to generate them.\n\n";
        }
    }
    print "\n";
    return;
}

sub check_destination_var_usage {
    return unless $IS_CPANEL_DEST;

    my $var_usage;
    if ( open my $df_fh, '-|', '/bin/df', '-hP', '/var' ) {
        while (<$df_fh>) {

            # Filesystem            Size  Used Avail Use% Mounted on
            # /dev/simfs             20G  6.2G   14G  31% /
            if (m# \A /(?:\S+) \s+ ([0-9A-Z\.]+) \s+ ([0-9A-Z\.]+) \s+ ([0-9A-Z\.]+) \s+ ([0-9]+)% \s+ (\S+) #xms) {
                $var_usage = "[Size: $1] [Used: $2] [Avail: $3] [Use%: $4] [Mount point: $5]\n";
            }
        }
        close $df_fh;
    }

    if ($var_usage) {
        print_format( '/var', $var_usage );
    }
    return;
}

sub print_plesk_version_unsupported {
    my $plesk_version = shift;
    print "We're very sorry, but the Plesk server is using a version of Plesk that our migrations scripts do not support at this time ($plesk_version).\n\n";
    print "Our developers are actively working on support for this version of Plesk. We do not yet have an estimated time of completion.\n";
    print "Unfortunately, we will not be able to migrate the accounts at this time. We hope to see support for Plesk $plesk_version soon, and we appreciate your interest in cPanel!\n";
    exit;
}

sub verify_mysql_connectivity {
    my $mysql_output = mysql_test();
    if ( $mysql_output =~ /ERROR/ ) {

        # If /root/.my.cnf exists, take no action other than providing a hint as to what the issue may be
        if ( -e '/root/.my.cnf' ) {
            print "Could not connect to MySQL (query failed: mysql -e 'select 1').\n";
            print "/root/.my.cnf already exists. Inspect it manually.\n";

            if ( $IS_PLESK and version_compare( $PLESK_MAJOR_VERSION . "." . $PLESK_MINOR_VERSION, '>=', '10.2' ) ) {
                print "Hint: try user 'admin' and the password from /usr/local/psa/bin/admin --show-password OR the contents of /etc/psa/.psa.shadow.\n";
            }
            elsif ( $IS_PLESK or $IS_PLESK_SMB10 ) {
                print "Hint: try user 'admin' and the contents of /etc/psa/.psa.shadow.\n";
            }
            elsif ($IS_DA) {
                print "Hint: try the credentials from /usr/local/directadmin/conf/mysql.conf .\n";
            }
            elsif ($IS_ENSIM) {
                print "Hint: try with the user 'root' and the password from this command:\n";
                print 'ensim-python -c "import sys ; sys.path.append(\'/usr/lib/opcenter/mysql\') ; import mysqlbe ; print mysqlbe.read_mysqlpass()"' . "\n";
            }
            elsif ($IS_CPANEL) {
                print "Hint: try with mysql user 'root' and the server's root password.\n";
            }
            else {
                print "[!] Unable to determine control panel\n";
            }
            exit;
        }

        # If /root/.my.cnf does not exist, attempt to create it unless the server uses cPanel
        else {
            print "Could not connect to MySQL (/root/.my.cnf does not exist).";
            if ($IS_CPANEL) {
                print "\n";
            }
            else {
                print "Trying to create /root/.my.cnf now.\n";
            }
            umask 0077;    # so /root/.my.cnf is 0600
            if ( $IS_PLESK or $IS_PLESK_SMB10 ) {
                if ( -e '/etc/psa/.psa.shadow' ) {
                    open my $psa_fh, '<', '/etc/psa/.psa.shadow' or die "$!\n";
                    chomp( my $mysql_password = readline($psa_fh) );
                    close $psa_fh;

                    if ( !$mysql_password ) {
                        die "Could not obtain mysql password from /etc/psa/.psa.shadow\n";
                    }
                    else {
                        open my $mycnf_fh, '>', '/root/.my.cnf' or die "$!\n";
                        print $mycnf_fh "[client]\nuser=admin\npassword=\"" . $mysql_password . "\"\n";
                        close $mycnf_fh;
                    }
                }
                else {
                    die "Attempted to obtain mysql password from /etc/psa/.psa.shadow, but it does not appear to exist\n";
                }
            }
            elsif ($IS_DA) {
                if ( -e '/usr/local/directadmin/conf/mysql.conf' ) {
                    open my $mysqlconf_fh, '<', '/usr/local/directadmin/conf/mysql.conf' or die "$!\n";

                    my $mysql_password;
                    while (<$mysqlconf_fh>) {
                        if (m{ \A passwd=(.*) \z }xms) {
                            chomp( $mysql_password = $1 );
                        }
                    }
                    close $mysqlconf_fh;

                    if ( !$mysql_password ) {
                        die "Could not obtain mysql password from /usr/local/directadmin/conf/mysql.conf\n";
                    }
                    else {
                        open my $mycnf_fh, '>', '/root/.my.cnf' or die "$!\n";
                        print $mycnf_fh "[client]\nuser=da_admin\npassword=\"" . $mysql_password . "\"\n";
                        close $mycnf_fh;
                    }
                }
                else {
                    die "Attempted to obtain mysql password from /usr/local/directadmin/conf/mysql.conf, but it does not appear to exist\n";
                }
            }
            elsif ($IS_ENSIM) {
                chomp( my $mysql_password = `ensim-python -c "import sys ; sys.path.append('/usr/lib/opcenter/mysql') ; import mysqlbe ; print mysqlbe.read_mysqlpass()"` );
                if ( !$mysql_password ) {
                    die 'Unable to determine mysql pass via this command: ' . "ensim-python -c \"import sys ; sys.path.append('/usr/lib/opcenter/mysql') ; import mysqlbe ; print mysqlbe.read_mysqlpass()\"\n";
                }
                else {
                    open my $mycnf_fh, '>', '/root/.my.cnf' or die "$!\n";
                    print $mycnf_fh "[client]\nuser=root\npassword=\"" . $mysql_password . "\"\n";
                    close $mycnf_fh;
                }
            }
            elsif ($IS_CPANEL) {
                die "You will need to manually create /root/.my.cnf\n";
            }
            else {
                die "[!] Unable to determine control panel\n";
            }

            # After creating /root/.my.cnf, see if we can connect to MySQL now. If not, remove our /root/.my.cnf and exit
            my $final_check = mysql_test();
            if ( $final_check =~ /ERROR/ ) {

                #unlink '/root/.my.cnf' or die "Could not remove our custom /root/.my.cnf\n";
                die "Still unable to connect to MySQL, even after creating /root/.my.cnf . Check contents of our custom /root/.my.cnf\n";
            }
            else {
                print "We can now connect to MySQL, proceeding.\n";
            }
        }
    }
    return;
}

## print control panel version
sub print_control_panel_info {
    my $panel_version;

    if ($IS_CPANEL) {
        if ( open my $file_fh, '<', '/usr/local/cpanel/version' ) {
            chomp( $panel_version = readline $file_fh );
            close $file_fh;
        }

        if ($panel_version) {
            if ( $OPTS->{'cpanelsource'} ) {
                $SRC_PANEL_VERSION = "cPanel " . $panel_version;
            }
            else {
                $DST_PANEL_VERSION = "cPanel " . $panel_version;
                $CPANEL_VERSION    = $panel_version;
            }
        }
        else {
            $DST_PANEL_VERSION = "cPanel (version unknown)";
        }
    }
    elsif ( $IS_PLESK or $IS_PLESK_SMB10 ) {
        if ( open my $file_fh, '<', '/usr/local/psa/version' ) {
            while (<$file_fh>) {
                if (m{ \A ([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}) }xms) {
                    $panel_version = $1;
                }
            }
            close $file_fh;
        }

        if ($panel_version) {
            $SRC_PANEL_VERSION = "Plesk " . $panel_version;
        }
        else {
            $SRC_PANEL_VERSION = "Plesk (version unknown)";
        }
    }
    elsif ($IS_ENSIM) {
        $panel_version = `/usr/bin/getapplversion` or die("Unable to discern Ensim version");
        if ( $panel_version =~ /^([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2})-.*$/ ) {
            $panel_version = $1;
        }

        if ($panel_version) {
            $SRC_PANEL_VERSION = "Ensim " . $panel_version;
        }
        else {
            $SRC_PANEL_VERSION = "Ensim (version unknown)";
        }
    }
    elsif ($IS_DA) {
        $panel_version = `/usr/local/directadmin/directadmin v` or die("Unable to discern DirectAdmin version");
        if ( $panel_version =~ /^Version: DirectAdmin v.([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2})$/ ) {
            $panel_version = $1;
        }

        if ($panel_version) {
            $SRC_PANEL_VERSION = "DirectAdmin " . $panel_version;
        }
        else {
            $SRC_PANEL_VERSION = "DirectAdmin (version unknown)";
        }
    }

    print "[ " . $DST_PANEL_VERSION . " ]\n" if $DST_PANEL_VERSION;
    print "[ " . $SRC_PANEL_VERSION . " ]\n" if $SRC_PANEL_VERSION;
    return;
}

sub print_os_info {
    my $os;

    if ( $^O =~ /linux/i ) {
        $os = 'Linux';
    }
    elsif ( $^O =~ /freebsd/i ) {
        $os = 'FreeBSD';
    }
    else {
        $os = 'Unknown';
    }

    if ( $os eq 'Linux' ) {
        my @release_files = qw(
          adamantix_version
          arch-release
          conectiva-release
          debian_release
          debian_version
          fedora-release
          gentoo-release
          immunix-release
          knoppix-version
          libranet_version
          mandrakelinux-release
          mandrake-release
          pardus-release
          redflag-release
          redhat-release
          redhat_version
          slackware-release
          slackware-version
          SuSE-release
          tinysofa-release
          trustix-release
          turbolinux-release
          va-release
          yellowdog-release
          yoper-release
        );

        for my $release_file (@release_files) {
            my $release_file_path = '/etc/' . $release_file;
            if ( -e $release_file_path ) {
                if ( open my $rel_fh, '<', $release_file_path ) {
                    while (<$rel_fh>) {
                        if    (/(\d+\.\d+)/) { $OS_VERSION = $1; last; }
                        elsif (/(\d+)/)      { $OS_VERSION = $1; last; }
                    }
                    close $rel_fh;
                }
                $release_file =~ s/release//g;
                $release_file =~ s/version//g;
                $release_file =~ s/[-_]//g;

                if ( $release_file eq 'redhat' ) {
                    $release_file = 'Redhat/CentOS';
                }
                $OS_DIST = $release_file;    # global
                $os .= " (" . $release_file;
                $os .= defined($OS_VERSION) ? " " . $OS_VERSION . ")" : ")";
                last;
            }
        }
    }

    #    print 'OS: ' . "$os\n";
    print_format( 'OS', $os );
    return;
}

sub print_format {
    my ( $str1, $str2 ) = @_;

    # It's going to be difficult to replace format, we don't know if the target system we're running on has Perl6::Form or other replacements, so silence perlcritic about this.
    ## no critic (CommaSeparatedStatements, Formats)
    format =
@>>>>>>>>>>>>>>>>>>>> @< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$str1, ':', $str2
.

    write;
    ## use critic
    return;
}

sub print_perl_info {

    # Previously read in output from 'perl -v', then tried to use $^V, but these proved to be unreliable.
    my $perl_version = $];
    if ( $perl_version && $perl_version =~ /^(\d+)\.(\d{3})(\d{3})/ ) {
        $perl_version = join( '.', ( $1 + 0 ), ( $2 + 0 ), ( $3 + 0 ) );
    }

    if ( !$perl_version ) {
        $perl_version = 'Unknown';
    }
    else {
        if ( version_compare( $perl_version, qw( < 5.6.2.0 ) ) ) {
            $perl_version = $perl_version . ' [ PERL MUST BE 5.6.2+ ]';
        }
    }

    print_format( 'Perl', $perl_version );
    return;
}

sub print_mysql_info {
    my $mysql_version = `mysql --version`;
    if ( $mysql_version =~ /Ver [0-9]{1,2}\.[0-9]{1,2} Distrib ([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}[a-z]?)/ ) {
        $mysql_version = $1;
    }
    else {
        $mysql_version = 'Unknown';
    }

    if ( $mysql_version ne 'Unknown' ) {
        if ( version_compare( $mysql_version, qw( < 4.1 ) ) ) {
            $mysql_version .= " :UNSUPPORTED\n";
        }
    }

    print_format( 'MySQL', $mysql_version );
    return;
}

sub print_php_info {
    my $php_version = `php -v 2>/dev/null`;
    my $php_major_version;
    my $cpanel_php_handler;

    if ( $php_version =~ m{ \A PHP \s (\S+) \s }xms ) {
        $php_version = $1;
    }
    else {
        $php_version = 'Unknown';
    }

    if ( $php_version =~ /^(\d)+\./ ) {
        $php_major_version = $1;
    }

    if ( $php_major_version and $IS_CPANEL == 1 ) {
        my $phpconf = `/usr/local/cpanel/bin/rebuild_phpconf --current 2> /dev/null`;
        if ( $phpconf && -f '/etc/cpanel/ea4/is_ea4' ) {    # EA4
            $php_version .= " [EA4]";
            my $pkg;
            foreach my $line ( split( /\n/, $phpconf ) ) {
                if ( $line =~ /DEFAULT PHP: (ea-php\d{1,2})/ ) {
                    $pkg = $1;
                    next;
                }
                if ( $line =~ /${pkg} SAPI: (.+)$/ ) {
                    $cpanel_php_handler = $1;
                    last;
                }
            }
        }
        elsif ( open my $file_fh, '<', '/usr/local/apache/conf/php.conf.yaml' ) {    # EA3
            $php_version .= " [EA3]";
            while (<$file_fh>) {
                if (/^php${php_major_version}:\s(\S+)/) {
                    $cpanel_php_handler = $1;
                    last;
                }
            }
            close $file_fh;
        }
    }

    if ($cpanel_php_handler) {
        $php_version .= " (handler: $cpanel_php_handler)";
    }

    print_format( 'PHP', $php_version );
    return;
}

sub print_apache_info {
    my $apache_version;
    my @apache_binaries = qw( httpd apache2 http2 httpd2 apache );

    for my $apache_binary (@apache_binaries) {
        $APACHE_BIN = _find_bin($apache_binary);
        if ($APACHE_BIN) {
            last;
        }
    }

    if ($APACHE_BIN) {
        $apache_version = `$APACHE_BIN -v`;
        if ( $apache_version =~ m{ \A Server \s version: \s Apache/(\S+) \s }xms ) {
            $apache_version = $1;
        }
    }
    else {
        $apache_version = 'Unknown';
    }

    print_format( 'Apache', $apache_version );
    return;
}

sub mem_rounded {
    my ($mem_size) = @_;
    my $chip_size  = 1;
    my $chip_guess = ( $mem_size / 8 ) - 1;
    while ( $chip_guess != 0 ) {
        $chip_guess >>= 1;
        $chip_size <<= 1;
    }
    my $mem_round = ( int( $mem_size / $chip_size ) + 1 ) * $chip_size;
    return $mem_round;
}

sub print_cpu_info {
    my ( $model, $mhz ) = ();
    my $numcores = 0;
    if ( open my $cpuinfo_fh, '<', '/proc/cpuinfo' ) {
        for my $line ( readline $cpuinfo_fh ) {
            if ( $line =~ /^model name/m ) {
                $line =~ s/^model name\s+:\s+//;
                $line =~ s/\(R\)//g;
                $line =~ s/\(tm\)//g;
                $line =~ s/\s{2,}/ /;
                $line =~ s/\s*\@/ \@/;
                $model = $line;
                chomp $model;
                $numcores++;
            }
            if ( $line =~ /^cpu MHz/m ) {
                $line =~ s/^cpu MHz\s+:\s+//;
                $mhz = $line;
                chomp $mhz;
            }
        }
        close $cpuinfo_fh;
    }
    else {
        return;
    }
    print_format( 'CPU', $model . ' w/ ' . $numcores . ' cores' );
    return;
}

sub print_mem_info {
    if ( $^O =~ /freebsd/i ) {
        my $sysctl        = {};
        my $sysctl_output = `/sbin/sysctl -a`;
        foreach my $line ( split( /\n/, $sysctl_output ) ) {
            if ( $line =~ m/^([^:]+):\s+(.+)\s*$/s ) {
                $sysctl->{$1} = $2;
            }
        }

        my $mem_hw       = mem_rounded( $sysctl->{"hw.physmem"} );
        my $mem_inactive = $sysctl->{"vm.stats.vm.v_inactive_count"} * $sysctl->{"hw.pagesize"};
        my $mem_cache    = $sysctl->{"vm.stats.vm.v_cache_count"} * $sysctl->{"hw.pagesize"};
        my $mem_free     = $sysctl->{"vm.stats.vm.v_free_count"} * $sysctl->{"hw.pagesize"};

        my $mem_total = $mem_hw / 1024 / 1024;
        my $mem_avail = int( ( $mem_inactive + $mem_cache + $mem_free ) / 1024 / 1024 );

        print_format( 'Memory', "${mem_total}MB (Free: ${mem_avail}MB)" );
    }
    else {
        my $in = `free -m`;
        if ( $in =~ /Mem:[\s]+([0-9]+)[\s]+[0-9]+[\s]+([0-9]+)[\s]+[0-9]+[\s]+[0-9]+[\s]+([0-9]+)/ ) {
            my $total = $1;
            my $free  = $2;
            my $cache = $3;
            print_format( 'Memory', "${total}MB (Free: " . ( $free + $cache ) . "MB)" );
        }
    }
    return;
}

sub print_number_of_accounts {
    print_format( 'Accounts', $TUD_USER_NUM );
    return;
}

sub print_dedicated_ipaddrs {
    my $result;
    my ( @usedips, @freeips );

    # From the earlier check, /etc/domainips should exist.
    if ( open( my $domainips_fh, '<', '/etc/domainips' ) ) {
        while (<$domainips_fh>) {
            push( @usedips, ' ' . $_ ) if $_ =~ /^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}: /;
        }
        close $domainips_fh;
    }

    return if ( scalar @usedips == 0 );

    $result = scalar(@usedips) . " Used";

    # Get Free Count if cPanel
    if ($IS_CPANEL_DEST) {
        my $cmd = `/scripts/ipusage`;
        my @ipusage = split( "\n", $cmd );
        foreach (@ipusage) {
            chomp $_;
            push( @freeips, $1 ) if $_ =~ /^([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}) $/;
        }
        $result .= " (" . scalar(@freeips) . " Free)";
    }

    # Tack on the sites in question
    $result .= "\n";
    foreach (@usedips) {
        $result .= $_;
    }

    print_format( 'Dedicated IPAddrs', $result );
    return;
}

sub print_mysql_db_count {
    my @alldbs = split( "\n", sqlcmd('show databases;') );
    my @userdbs = grep { !/^(?:logaholicDB_.+|information_schema|performance_schema|cphulkd|eximstats|horde|leechprotect|mysql|(?:da_)?roundcube|atmail|admin_appl|psa|phpmyadmin_.+|sitebuilder5)$/ } @alldbs;

    if ( scalar @userdbs > 0 ) {
        print_format( 'MySQL DBs', @alldbs . " (" . @userdbs . " User Created)" );
    }
    return;
}

sub sqlcmd {
    my ($cmd) = @_;
    my $result;
    my $wtrfh;
    my $rdrfh;
    my $mysql  = _find_bin('mysql');
    my $passwd = get_mysql_auth();

    my $user = $passwd->{'user'};
    my $pass;

    ## TODO: .my.cnf can use pas, pass, passw, passwo, passwor, and password
    if ( $passwd->{'password'} ) {
        $pass = $passwd->{'password'};
    }
    elsif ( $passwd->{'passwd'} ) {
        $pass = $passwd->{'passwd'};
    }
    elsif ( $passwd->{'pass'} ) {
        $pass = $passwd->{'pass'};
    }

    my $pid = IPC::Open3::open3( $wtrfh, $rdrfh, $rdrfh, $mysql, '-N', '-u', $user, "--password=$pass" );
    print {$wtrfh} "$cmd\n";
    close($wtrfh);
    local $/;    ## no critic (InitializationForLocalVars)
    $result = readline($rdrfh);
    waitpid( $pid, 0 );

    if ( $result =~ /^ERROR.*Access denied/ ) {
        die("Unable to discern correct MySQL user & password - MySQL said:\n$result");
    }
    return $result;
}

sub get_mysql_auth {
    my $data            = {};
    my $my_cnf_path     = '/root/.my.cnf';
    my $psa_shadow_path = '/etc/psa/.psa.shadow';
    if ($IS_CPANEL) {
        if ( -f $my_cnf_path ) {
            my $mycnf;
            if ( open( my $mycnf_fh, '<', $my_cnf_path ) ) {
                while (<$mycnf_fh>) {
                    $mycnf .= $_;
                }
                close $mycnf_fh;
            }

            if ( $mycnf =~ /\[client\] (.+?) (\n \s* \[ | $)/xs ) {
                my @clientblock = split "\n", $1;
                foreach (@clientblock) {
                    chomp($_);
                    my ( $key, $value ) = split /=/, $_, 2;
                    next if !$value;
                    if ( $value =~ /^['"](.+)['"]$/ ) {
                        $data->{$key} = $1;
                    }
                    else {
                        $data->{$key} = $value;
                    }
                }
            }
        }
        else {
            die('/root/.my.cnf missing');
        }
    }
    elsif ( $IS_PLESK or $IS_PLESK_SMB10 ) {
        if ( -f $psa_shadow_path ) {
            my $psa;
            if ( open( my $psa_fh, '<', $psa_shadow_path ) ) {
                while (<$psa_fh>) {
                    $psa .= $_;
                }
                close $psa_fh;
            }
            chomp($psa);
            $data->{'user'} = 'admin';
            $data->{'pass'} = $psa;
        }
        else {
            die( $psa_shadow_path . '  missing' );
        }
    }
    elsif ($IS_ENSIM) {
        my @python_binaries = qw( ensim-python python python2 python2.1 python2.4 );

        for my $python_binary (@python_binaries) {
            $PYTHON_BIN = _find_bin($python_binary);
            if ($PYTHON_BIN) {
                last;
            }
        }

        local $ENV{'PYTHONPATH'} = '/usr/lib/opcenter/mysql/';
        $data->{'pass'} = `$PYTHON_BIN -c 'from mysqlbe import *; print read_mysqlpass();'`;
        chomp( $data->{'pass'} );
        $data->{'user'} = 'root';
    }
    elsif ($IS_DA) {
        if ( -f "/usr/local/directadmin/conf/mysql.conf" ) {
            if ( open( my $fh, '<', "/usr/local/directadmin/conf/mysql.conf" ) ) {
                while ( my $line = <$fh> ) {
                    chomp($line);
                    my ( $key, $value ) = split /=/, $line;
                    next if !$value;
                    $data->{$key} = $value;
                }
                close $fh;
                $data->{'pass'} = $data->{'passwd'};
            }
        }
        else {
            die('/usr/local/directadmin/conf/mysql.conf missing');
        }
    }

    my @passwords = qw( pass passw passwo passwor password passwd );    # does 'passwd' work?
    for my $pass (@passwords) {
        if ( $data->{$pass} ) {
            $data->{'pass'} = $data->{$pass};
            last;
        }
    }

    if ( !$data->{'user'} || !$data->{'pass'} ) {
        die('Unable to find MySQL root user or password');
    }
    else {
        return $data;
    }
    return;
}

sub print_postgres_db_count {
    if ( _find_bin('psql') ) {
        if ( find_psql_socket() ) {
            if ( my $rawsql = psqlcmd("select datname from pg_database") ) {
                if ( $rawsql =~ /^Postgres Fatal/m ) { return "\n$rawsql" }
                my @alldbs = split( '\n', $rawsql );
                my @userdbs = grep { !/^(?:postgres|template[0-1])$/ } @alldbs;

                if ( scalar @userdbs > 0 ) {
                    print_format( 'Postgres DBs', @alldbs . " (" . @userdbs . " User Created)" );
                }
            }
        }
    }
    return;
}

sub find_psql_socket {
    my $pid = `lsof -U -a -u postgres -t 2>/dev/null`;
    return $pid;
}

sub psqlcmd {
    my ($cmd) = @_;
    my $result;
    my $rdrfh;
    my $psql   = _find_bin('psql');
    my $passwd = get_psql_auth();

    my $user = $passwd->{'user'};
    my $pass = $passwd->{'pass'};

    local $ENV{'PGUSER'}     = $user;
    local $ENV{'PGPASSWORD'} = $pass;

    # Plesk only authenticates Postgres logins when you're logged in as the postgres user
    # So, we'll just "su" to the postgres user for all panels anyway.
    my $psqlcmd = "cd; $psql -A -F \\| -c '$cmd'";

    #my $pid = IPC::Open3::open3( undef, $rdrfh, undef, 'su', $user, '-c', $psqlcmd );
    my $pid = IPC::Open3::open3( undef, $rdrfh, undef, $psqlcmd );
    local $/;    ## no critic (InitializationForLocalVars)
    $result = readline($rdrfh);
    waitpid( $pid, 0 );
    if ( $result =~ /\n\([0-9]+ rows\)$/m ) {
        if ( $result =~ /.*\n([^\n]+\n{$1})\([0-9]+ rows\)$/m ) {
            $result = $1;
        }
    }
    elsif ( $result =~ /^(psql|su):/ ) {
        if ( $result =~ /FATAL:[\s]+database "$user" does not exist/ ) {

            # It's installed and running, but not configured.  Return undef.
            return;
        }
        else {
            chomp $result;
            return ("Postgres Fatal Error - Postgres said: $result");
        }
    }

    return $result;
}

sub get_psql_auth {
    my $data        = {};
    my $pgpass_path = '/root/.pgpass';
    if ($IS_CPANEL) {
        if ( -f $pgpass_path ) {
            my $mycnf;
            if ( open( my $pgpass_fh, '<', $pgpass_path ) ) {
                while (<$pgpass_fh>) {
                    $mycnf .= $_;
                }
                close $pgpass_fh;
            }
            if ( $mycnf =~ /[^:]+:[^:]+:[^:]+:postgres:([\S]+)/m ) {
                $data->{'user'} = "postgres";
                $data->{'pass'} = $1;
            }
            else {
                $data->{'user'} = "postgres";
                $data->{'pass'} = "";
            }
        }
        else {
            $data->{'user'} = "postgres";
            $data->{'pass'} = "";
        }
    }
    if ( $IS_PLESK or $IS_PLESK_SMB10 ) {
        my $line = sqlcmd("use psa; SELECT admin_login, admin_password FROM DatabaseServers WHERE type='postgresql'");
        my ( $user, $pass ) = split /\s+/, $line;
        $data->{'user'} = $user;
        $data->{'pass'} = $pass;
    }
    else {
        $data->{'user'} = "postgres";
        $data->{'pass'} = "";
    }
    return $data;
}

sub print_custom_apache_modules {
    my @custom;

    # Last reviewed: 08/20/2015
    # Cpanel::Easy::Apache v3.30.0 rev9999
    # EasyApache Basic Profile module list from 'httpd -l' for Apache 2.2 and 2.4 combined
    my @base = qw(
      core.c
      http_core.c
      mod_access_compat.c
      mod_actions.c
      mod_alias.c
      mod_asis.c
      mod_auth_basic.c
      mod_authn_core.c
      mod_authn_default.c
      mod_authn_file.c
      mod_authz_core.c
      mod_authz_default.c
      mod_authz_groupfile.c
      mod_authz_host.c
      mod_authz_user.c
      mod_autoindex.c
      mod_cgi.c
      mod_deflate.c
      mod_dir.c
      mod_env.c
      mod_expires.c
      mod_filter.c
      mod_headers.c
      mod_include.c
      mod_info.c
      mod_log_config.c
      mod_logio.c
      mod_mime.c
      mod_negotiation.c
      mod_proxy_ajp.c
      mod_proxy_balancer.c
      mod_proxy.c
      mod_proxy_connect.c
      mod_proxy_ftp.c
      mod_proxy_http.c
      mod_proxy_scgi.c
      mod_rewrite.c
      mod_setenvif.c
      mod_slotmem_shm.c
      mod_so.c
      mod_socache_dbm.c
      mod_socache_shmcb.c
      mod_ssl.c
      mod_status.c
      mod_suexec.c
      mod_unique_id.c
      mod_unixd.c
      mod_userdir.c
      mod_version.c
      prefork.c
    );

    my $apachem = `$APACHE_BIN -l 2> /dev/null`;
    if ( $apachem =~ /in modules:\s([^\[]+)[\s]?$/m ) {
        my @mods = split( "\n", $1 );
        foreach (@mods) {
            my $mod = $_;
            $mod =~ s/^\s+//;
            push( @custom, " " . $mod . "\n" ) unless grep { /^$mod$/ } @base;
        }
    }

    return if !@custom;

    print "\nNon-default Apache Modules:\n";
    for my $module (@custom) {
        chomp $module;
        print "$module\n";
    }
    return;
}

sub print_custom_php_modules {
    my @custom;

    # Last reviewed: 08/20/2015
    # Cpanel::Easy::Apache v3.30.0 rev9999
    # EasyApache Basic Profile module list from 'php -m' for PHP 5.4
    my @base = qw(
      bcmath
      calendar
      Core
      ctype
      curl
      date
      dom
      ereg
      filter
      ftp
      gd
      hash
      iconv
      imap
      json
      libxml
      mcrypt
      mysql
      mysqlnd
      openssl
      pcre
      PDO
      pdo_mysql
      pdo_sqlite
      Phar
      posix
      Reflection
      session
      SimpleXML
      sockets
      SPL
      sqlite3
      standard
      tokenizer
      xml
      xmlreader
      xmlwriter
      zlib
    );

    # Modules that EasyApache does not support
    my @ignore = qw(
      dbase
      gmp
      ldap
      pcntl
      readline
      shmop
      sysvmsg
      sysvsem
      sysvshm
    );

    # tack them onto @mods so they're disregarded
    push @base, @ignore;

    my $phpm = `php -m 2> /dev/null`;
    if ( $phpm =~ /^\[PHP Modules\]\s([^\[]+)[\s]?$/m ) {
        my @mods = split( "\n", $1 );
        foreach (@mods) {
            my $mod = $_;
            push( @custom, " " . $mod . "\n" ) unless grep { /^$mod$/ } @base;
        }
    }

    if (@custom) {
        @custom = sort @custom;
    }

    return if !@custom;

    print "\nNon-default PHP Modules:\n";
    for my $module (@custom) {
        chomp $module;
        print "$module\n";
    }
    return;
}

sub _find_bin {
    my $bin = shift;

    my @bin_search_paths = qw(
      /usr/local/apache/bin
      /etc/apache/bin
      /bin
      /usr/bin
      /usr/sbin
      /usr/local/bin
      /usr/local/sbin
      /usr/libexec
      /usr/local/libexec
    );

    for my $bin_search_path (@bin_search_paths) {
        my $bin_tmp = "${bin_search_path}/${bin}";
        if ( -e $bin_tmp ) {
            $bin = $bin_tmp;
            last;
        }
    }

    if ( $bin =~ /\// ) {
        return $bin;
    }
    return;
}

sub _get_trueuserdomains_hashrefs {
    check_trueuserdomains();
    my $tud = '/etc/trueuserdomains';
    my $tud_by_user_ref;
    my $tud_by_domain_ref;
    die "${tud} does not exist!\n" if not -f $tud and not $IS_CPANEL_DEST;
    if ( open my $tud_fh, '<', $tud ) {
        while (<$tud_fh>) {
            chomp;

            # Must let undefined values pass through in order for badusers check to work.
            my ( $domain, $user ) = ( split( /\s*:\s*/, $_, 3 ) )[ 0, 1 ];

            # ticket system creates temporary user in cp12345678abcdef format, ignore these
            next if defined $user and $user =~ /^cp[0-9]{7,8}[a-z]{6}$/;

            # strip site number from Ensim usernames
            $user =~ s/\^site(\d+)//g if defined $user;
            push @{ $tud_by_user_ref->{$user} },     $domain;
            push @{ $tud_by_domain_ref->{$domain} }, $user;
        }
        close $tud_fh;
    }
    else {
        die "Could not open ${tud}: $!\n" unless $IS_CPANEL_DEST;
    }
    return $tud_by_user_ref, $tud_by_domain_ref;
}

sub print_prefixed_panel_info {
    if ($SRC_PANEL_VERSION) {
        print $PREFIX . 'VERSION:' . $SRC_PANEL_VERSION . "\n";
    }
    elsif ($DST_PANEL_VERSION) {
        print $PREFIX . 'VERSION:' . $DST_PANEL_VERSION . "\n";
    }
    return;
}

sub print_prefixed_os_info {
    print $PREFIX . 'OS_DIST:' . $OS_DIST . "\n"       if defined($OS_DIST);
    print $PREFIX . 'OS_VERSION:' . $OS_VERSION . "\n" if defined($OS_VERSION);
    return;
}

sub print_prefixed_php_info {
    my $php_version = `php -v 2>/dev/null`;
    my $ea4 = ( $IS_CPANEL && -f '/etc/cpanel/ea4/is_ea4' ) ? '1' : '0';

    if ( $php_version =~ m{ (\d{1,2}\.\d{1,2})\. }xms ) {
        $php_version = $1;
    }
    else {
        $php_version = 'Unknown';
    }

    print $PREFIX . "PHP:" . $php_version . "\n";
    print $PREFIX . "EA4:" . $ea4 . "\n" if $IS_CPANEL;
    return;
}

sub print_prefixed_mysql_info {
    my $mysql_version = `mysql --version`;
    if ( $mysql_version =~ /Ver [0-9]{1,2}\.[0-9]{1,2} Distrib ([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}[a-z]?)/ ) {
        $mysql_version = $1;
    }
    else {
        $mysql_version = 'Unknown';
    }

    if ( $mysql_version ne 'Unknown' ) {
        if ( version_compare( $mysql_version, qw( < 4.1 ) ) ) {
            print $PREFIX . 'MYSQL:' . $mysql_version . ":UNSUPPORTED\n";
        }
        else {
            print $PREFIX . 'MYSQL:' . "$mysql_version\n";
        }
    }
    return;
}

sub print_prefixed_bad_username_info {
    if ( $PREFIX =~ /^s/ ) {
        for my $user ( sort keys %{$TUD_BY_USER} ) {
            if ( $user =~ m{ \A (.*[\-\._]|test|[0-9]|[A-Z]) }xms ) {
                print $PREFIX . 'BADUSER:' . $user . "\n";
                push @BADUSERS, $user;
            }
        }
    }
    return;
}

sub print_prefixed_duplicate_users {    # WHM 11.44+ requires first 8 characters of username to be unique for database prefixing
    my %first8;
    my $print_dupes = sub {
        my ( $href, $printkey ) = @_;
        for my $key ( sort keys %{$href} ) {
            if ( scalar( my @dupes = @{ $href->{$key} } ) > 1 ) {
                for my $dupe ( sort @dupes ) {
                    print $PREFIX . $printkey . ':' . $key . ':' . $dupe . "\n";
                }
            }
        }
    };
    for my $user ( sort keys %{$TUD_BY_USER} ) {
        if ( length($user) >= 8 ) {
            my $user8 = substr( $user, 0, 8 );
            push @{ $first8{$user8} }, $user . ' (' . $TUD_BY_USER->{$user}->[0] . ')';
        }
    }
    &$print_dupes( $TUD_BY_USER,   'DUPLICATE_USER' );
    &$print_dupes( \%first8,       'DUPLICATE_FIRST8' );
    &$print_dupes( $TUD_BY_DOMAIN, 'DUPLICATE_DOMAIN' );
    return;
}

sub print_prefixed_dedicated_ip_addr_info {
    my @source_used_ipaddrs;
    my @cpanel_free_ipaddrs;
    my $cpanel_free_ipaddrs;

    if ( $PREFIX =~ /^s/ ) {
        if ( open my $domainips_fh, '<', '/etc/domainips' ) {
            while (<$domainips_fh>) {
                if (/^(?:\d+\.\d+\.\d+\.\d+):\s(.*)/) {
                    push @source_used_ipaddrs, $1;
                }
            }
            close $domainips_fh;
        }

        print $PREFIX . 'IPADDRS_USED:' . scalar @source_used_ipaddrs . "\n";

        for my $site (@source_used_ipaddrs) {
            chomp $site;
            print $PREFIX . 'DEDICATED_SITE:' . $site . "\n";
        }
    }
    elsif ( $PREFIX =~ /^d/ ) {
        if ( open my $command_fh, '-|', '/scripts/ipusage' ) {
            while (<$command_fh>) {
                if (m{ \A \d+ \. \d+ \. \d+ \. \d+ \s+ \z }xms) {
                    push @cpanel_free_ipaddrs, $_;
                }
            }
            close $command_fh;
        }

        $cpanel_free_ipaddrs = scalar @cpanel_free_ipaddrs;

        print $PREFIX . 'IPADDRS_FREE:' . $cpanel_free_ipaddrs . "\n";
    }
    return;
}

sub print_prefixed_hosting_types {
    if (@HOSTING_TYPE_FORWARD) {
        for my $line (@HOSTING_TYPE_FORWARD) {
            if ( $line =~ m{ \A (\S+) \s forwarded \s to \s -> \s (\S+) }xms ) {
                print $PREFIX . 'FORWARDING_DOMAIN:' . $1 . $2 . "\n";
            }
        }
    }

    if (@HOSTING_TYPE_NOHOSTING) {
        for my $domain (@HOSTING_TYPE_NOHOSTING) {
            print $PREFIX . 'NOHOSTING_DOMAIN:' . $domain . "\n";
        }
    }
    return;
}

sub print_prefixed_tomcat_info {
    my $has_tomcat = 0;
    $has_tomcat = `ps aux | grep tomca[t]`;

    if ($has_tomcat) {
        print $PREFIX . 'TOMCAT:' . '1' . "\n";
    }
    else {
        print $PREFIX . 'TOMCAT:' . '0' . "\n";
    }
    return;
}

sub print_prefixed_coldfusion_info {
    my $has_coldfusion = 0;
    $has_coldfusion = `ps aux | grep coldfusio[n]`;

    if ($has_coldfusion) {
        print $PREFIX . 'COLDFUSION:' . '1' . "\n";
    }
    else {
        print $PREFIX . 'COLDFUSION:' . '0' . "\n";
    }
    return;
}

sub print_prefixed_reseller_username_conflicts {
    return if !@PLESK_RESELLER_USERNAME_CONFLICTS;

    for my $reseller (@PLESK_RESELLER_USERNAME_CONFLICTS) {
        print $PREFIX . 'RESELLER_CONFLICT:' . $reseller . "\n";
    }
    return;
}

sub print_prefixed_user_config_problems {
    if ($IS_DA) {
        my $configdir = '/usr/local/directadmin/data/users';
        if ( opendir my $dh, $configdir ) {
            for ( readdir $dh ) {
                my $user       = $_;
                my $configfile = $configdir . "/" . $_ . "/user.conf";
                if ( -f $configfile && open my $fh, '<', $configfile ) {
                    while (<$fh>) {
                        if (m{ ^ (?:[\s\t]+)? (bandwidth|quota) (?:[\s\t]+)? = (?:[\s\t]+)? ["']? (.+?) ['"]? $ }x) {
                            my $type  = uc($1);
                            my $value = $2;
                            next if $value =~ m{ ^ (\d+|unlimited) $ }x;
                            print $PREFIX . 'BAD_USER_CONFIG:' . $user . ':' . $type . ":\"" . $value . "\"\n";
                        }
                    }
                    close $fh;
                }
            }
            close $dh;
        }
    }
    return;
}

sub print_prefixed_php_information {
    my %ini = map { $_ => undef } qw (
      allow_url_fopen
      allow_url_include
      date.timezone
      memory_limit
      output_buffering
      post_max_size
      upload_max_filesize
    );

    my $phpini;
    my $php_want_array = q{"} . join( q{","}, sort keys %ini ) . q{"};
    my $php_out = `php -r '\$values=array(${php_want_array}); foreach (\$values as &\$value) {echo \$value . "=" . ini_get(\$value) . "\n";}' 2> /dev/null`;
    %ini = ( %ini, defined($php_out) ? map { ( split( /=/, $_, 2 ) )[ 0, 1 ] } split( /\n/, $php_out ) : () );
    for my $value ( values(%ini) ) {
        if ( defined $value ) {
            $ini{'parsed'} = 'php_output';
            last;
        }
    }
    unless ( defined $ini{'parsed'} ) {
        if ( $IS_PLESK or $IS_PLESK_SMB10 or $IS_ENSIM ) {
            $phpini = '/etc/php.ini';
        }
        elsif ( $IS_DA or ( $IS_CPANEL and not -e '/etc/cpanel/ea4/is_ea4' ) ) {
            $phpini = '/usr/local/lib/php.ini';
        }
        if ( defined($phpini) && open my $file_fh, '<', $phpini ) {
            while ( my $line = <$file_fh> ) {
                next if $line =~ m{ \A \s* (?:;|\Z) }xms;
                my ( $key, $value ) = split( /\s*=\s*/, $line );
                $key =~ s{ \A \s* }{}xms;
                $key = lc($key);
                next unless exists $ini{$key};
                chomp $value;
                $value =~ s{ ; .* \Z }{}xms;
                $value =~ s{ \s* \Z }{}xms;
                $value =~ s{ \A ['"] (.*) ['"] \Z}{$1}xms;
                $ini{$key} = $value;
            }
            close $file_fh;
            $ini{'parsed'} = $phpini;
        }
    }

    $ini{'parsed'} = 'FAIL' unless defined $ini{'parsed'};

    foreach my $bool (qw( output_buffering allow_url_fopen allow_url_include )) {    # These will return 0/1 from ini_get but are Off/On in php.ini
        next unless defined $ini{$bool};
        $ini{$bool} = ( $ini{$bool} eq "0" ) ? "Off" : $ini{$bool};
        $ini{$bool} = ( $ini{$bool} eq "1" ) ? "On"  : $ini{$bool};
    }
    foreach my $num (qw( memory_limit post_max_size upload_max_filesize )) {         # Strip the 'M' suffix from these
        next unless defined $ini{$num};
        $ini{$num} =~ s{ M \Z }{}xmsi;
    }
    foreach my $key ( sort( keys(%ini) ) ) {
        next if not defined( $ini{$key} ) or $ini{$key} eq "";
        my $printkey = uc($key);
        $printkey =~ tr/./_/;
        print $PREFIX . "PHPINI_" . $printkey . ":" . $ini{$key} . "\n";
    }
    return;
}

sub print_prefixed_cpanel_eula_accepted_check {
    return unless $IS_CPANEL;

    my @dir_contents;

    if ( -d '/var/cpanel/activate' ) {
        opendir( my $dir_fh, '/var/cpanel/activate' ) or return;
        @dir_contents = grep { /EULACPWHM/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    if ( !@dir_contents ) {
        print $PREFIX . 'EULA:' . '0' . "\n";
    }
    else {
        print $PREFIX . 'EULA:' . '1' . "\n";
        $EULA_ACCEPTED = 1;
    }
    return;
}

sub print_prefixed_mysql_username_conflict_info {
    return unless $IS_PLESK or $IS_PLESK_SMB10;

    my ( $user, $domain );
    my %mysql_layout;
    my @seen;

    my $domain_ids_and_names = `mysql -BN psa -e 'select id,name from domains order by id'`;
    my %domain_ids_and_names = split /\s/, $domain_ids_and_names;

    while ( my ( $domain_id, $trueuserdomain ) = each(%domain_ids_and_names) ) {
        next if not exists $TUD_BY_DOMAIN->{$trueuserdomain}->[0];
        my @dbusers = `mysql -BN psa -e '
                   select
                        db_users.login
                   from
                        db_users
                   inner join data_bases on data_bases.id = db_users.db_id
                   inner join domains on data_bases.dom_id = domains.id
                   where
                       data_bases.type = "mysql"
                       and domains.id = $domain_id'`;
        next if !@dbusers;
        $mysql_layout{$trueuserdomain}{ $TUD_BY_DOMAIN->{$trueuserdomain}->[0] } = [@dbusers];
    }

    for my $sysuser ( keys %{$TUD_BY_USER} ) {
        next if grep { /^$sysuser$/ } @seen;
        next if grep { /^$sysuser$/ } @BADUSERS;    # bad usernames must be renamed anyway
        for my $domain ( keys %mysql_layout ) {
            next if ( exists $mysql_layout{$domain}{$sysuser} );    # Plesk user alice can have a mysql user of the same name
            if ( grep { /^$sysuser$/ } @{ $mysql_layout{$domain}{ $TUD_BY_DOMAIN->{$domain}->[0] } } ) {
                for my $d ( keys %{$TUD_BY_DOMAIN} ) {
                    if ( exists $TUD_BY_DOMAIN->{$d}->[0] && $TUD_BY_DOMAIN->{$d}->[0] eq $sysuser ) {
                        print $PREFIX . 'MYSQL_CONFLICT:' . "${domain}:${sysuser}:${d}\n";
                        push @seen, $sysuser;                       # avoid checking the same user twice
                        last;
                    }
                }
            }
        }
    }
    return;
}

sub print_prefixed_mysql_openfileslimit {
    return unless $IS_CPANEL_DEST;

    # open_files_limit is auto-scaled with the Transfer Tool in 11.44+, but not when using /scripts/restorepkg
    # I want to re-enable this in the future if restorepkg is fixed to do this, but for now we need to keep checking.
    #    return if ( version_compare( $CPANEL_VERSION, qw( >= 11.44.0.0 ) ) );

    my $open_files_limit = `mysqladmin var | grep open_files_limit | awk '{print \$4}'`;
    chomp $open_files_limit;

    print $PREFIX . 'MYSQL_OPEN_FILES_LIMIT:' . $open_files_limit . "\n";
    return;
}

sub print_prefixed_mysql_skip_networking {
    return unless $IS_CPANEL_DEST;

    my $my_cnf = '/etc/my.cnf';

    if ( open my $my_cnf_fh, '<', $my_cnf ) {
        while (<$my_cnf_fh>) {
            chomp( my $line = $_ );
            if ( $line =~ m{ \A (?:[ \t]+)? (skip[_-]net.*) }xms ) {
                print $PREFIX . 'MYSQL_SKIP_NETWORKING:1' . "\n";
                last;
            }
        }
        close $my_cnf_fh;
    }
    return;
}

sub print_prefixed_mysql_old_style_passwords_info {
    ## if the source is using old_passwords=1 and the destination server is using MySQL >= 5.6,
    ## MySQL data may not restore properly

    return if $IS_CPANEL_DEST;

    my $my_cnf = '/etc/my.cnf';

    if ( open my $my_cnf_fh, '<', $my_cnf ) {
        while (<$my_cnf_fh>) {
            chomp( my $line = $_ );
            if ( $line =~ m{ \A (?:[ \t]+)? (old[_-]p.*=(?:[ \t]?)1) }xms ) {
                print $PREFIX . 'MYSQL_OLD_STYLE_PASSWORDS:1' . "\n";
                last;
            }
        }
        close $my_cnf_fh;
    }
    return;
}

sub print_prefixed_dns_clustering_info {
    return unless $IS_CPANEL_SOURCE and -e '/var/cpanel/useclusteringdns';

    my $cluster_dir = '/var/cpanel/cluster/root/config/';
    my @dir_contents;

    if ( -d $cluster_dir ) {
        opendir( my $dir_fh, $cluster_dir );
        @dir_contents = grep { !/^\.\.?$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    for my $dirent ( sort @dir_contents ) {
        my ( $cluster_member, $cluster_member_hostname, $cluster_member_role );
        my %cluster_conf;

        # only active cluster members have -dnsrole files
        if ( $dirent =~ m{ \A (.+)-dnsrole \z }xms ) {
            $cluster_member = $1;

            if ( open my $config_fh, '<', $cluster_dir . $cluster_member ) {
                local $/;    ## no critic (InitializationForLocalVars)
                %cluster_conf = map { ( split( /=/, $_, 2 ) )[ 0, 1 ] } split( /\n/, readline($config_fh) );
                close $config_fh;
            }
            $cluster_member_hostname = defined $cluster_conf{host} ? $cluster_conf{host} : '?';
            if ( $cluster_member =~ m{ \A (vps\.net|softlayer) \z}xmsi ) {
                $cluster_member_hostname = '';
            }

            $cluster_member_role = 'standalone';
            if ( open my $role_fh, '<', $cluster_dir . $cluster_member . "-dnsrole" ) {
                $cluster_member_role = readline $role_fh;
                chomp $cluster_member_role;
                close $role_fh;
            }
            print $PREFIX;
            print join( ':', 'DNSCLUSTER', $cluster_member_hostname, $cluster_member, $cluster_member_role );
            print "\n";
        }
    }
    return;
}

sub print_plesk_duplicate_email_users {

    # Plesk allowed creation of duplicate mixed-case email addresses, this reports those.
    # Prior to case FB-75913 mixed-case addresses were skipped entirely, but now we will copy a mixed-case address as all-lowercase if one doesn't already exist
    return unless $IS_PLESK or $IS_PLESK_SMB10;

    my $maildir = '/var/qmail/mailnames';
    return if !-d $maildir;

    my %dupes = ();
    my @output;

    ## get list of mail domains
    opendir( my $maildir_fh, $maildir );
    my @domains = grep { !/^\.\.?/ } readdir $maildir_fh;
    closedir $maildir_fh;

    ## get list of mail users
    for my $domain (@domains) {
        my $dupes;
        my $users_dir = "${maildir}/${domain}";
        next if !-d $users_dir;

        opendir( my $userdir_fh, $users_dir );
        my @mailusers = grep { !/^\.\.?/ } readdir $userdir_fh;
        closedir $userdir_fh;

        next if !@mailusers;

        my @lowercase_mailusers = map { lc } @mailusers;
        my %seen;
        for my $mailuser (@lowercase_mailusers) {
            $seen{$mailuser}++;
        }

        while ( my ( $k, $v ) = each(%seen) ) {
            if ( $v > 1 ) {
                for my $user (@mailusers) {
                    if ( $user =~ /^${k}$/i ) {
                        $dupes .= "$user, ";
                    }
                }
            }
        }

        if ($dupes) {
            $dupes =~ s/,\s$//g;
            $dupes = "[$domain] $dupes";
            push @output, $dupes;
        }
    }

    if (@output) {
        print "\n\nDuplicate email users:\n";
        for my $line (@output) {
            print " $line\n";
        }
    }
    return;
}

sub print_reseller_username_conflicts {

    # Case FB-76677 - [Plesk] If a reseller has a domain, copy it instead of making a "psa-reseller-$cpuser.invalid" domain
    # This was addressed by adding --reseller and --no-reseller options to pkgacct-pXa, so we still need to know which reseller usernames conflict with system usernames so they can be handled appropriately.
    return unless $IS_PLESK or $IS_PLESK_SMB10;
    my @plesk_resellers;

    my @reseller_query = `mysql -BN psa -e 'select login, type from clients'`;
    for my $line (@reseller_query) {
        chomp $line;
        if ( $line =~ m{ \A (\S+) \s+ reseller \z }xms ) {
            push @plesk_resellers, $1;
        }
    }

    if (@plesk_resellers) {
        for my $reseller (@plesk_resellers) {
            my $test = getpwnam $reseller;
            if ($test) {
                push @PLESK_RESELLER_USERNAME_CONFLICTS, $reseller;
            }
        }
    }
    return;
}

sub print_dest_existing_accounts {
    return unless $IS_CPANEL_DEST;
    return if $TUD_USER_NUM < 2;
    print "\n";
    print BOLD RED ON_BLACK "!!! ATTENTION !!!" . RESET . ": " . $TUD_USER_NUM . " accounts exist on this destination server.\n";
    print "Ensure that this destination server has been freshly installed as a destination for account migration.\n";
    print "See https://documentation.cpanel.net/display/CKB/cPanel+Migration+Services+and+Guides for migration requirements.\n";
    return;
}

sub parse_output_file {
    my $file = shift;

    if ( !-f $file ) {
        die "$file does not exist, or is not a regular file\n";
    }

    my ( $has_src,     $has_dst );
    my ( $src_os_dist, $dst_os_dist );
    my ( $src_os_ver,  $dst_os_ver );
    my ( $src_php,     $dst_php );
    my ( $src_mysql,   $dst_mysql );
    my $dst_ea4       = 0;
    my %badusers      = ();
    my %baduserconfig = ();
    my %dupe_users    = ();
    my %dupe_first8   = ();
    my %dupe_domains  = ();
    my ( $src_dedicated_ipaddrs_used, $dst_ipaddrs_free );
    my @sites_on_dedicated_ipaddrs;
    my ( @src_disk_usage, @dst_disk_usage );
    my %forwarding_domains = ();
    my @nohosting_domains;
    my ( $src_tomcat,     $dst_tomcat )     = ( 0, 0 );
    my ( $src_coldfusion, $dst_coldfusion ) = ( 0, 0 );
    my @reseller_username_conflicts;
    my ( $src_phpini_memory_limit,        $dst_phpini_memory_limit );
    my ( $src_phpini_post_max_size,       $dst_phpini_post_max_size );
    my ( $src_phpini_upload_max_filesize, $dst_phpini_upload_max_filesize );
    my ( $src_phpini_date_timezone,       $dst_phpini_date_timezone );
    my ( $src_phpini_output_buffering,    $dst_phpini_output_buffering );
    my @mysql_username_conflicts;
    my $open_files_limit;
    my $skip_networking;
    my $mysql_old_style_passwords;
    my %dns_cluster;

    open( my $file_fh, '<', $file ) or die "Could not open $file: $!\n";    ## no critic (BriefOpen) # We DO close this later.
    while (<$file_fh>) {
        chomp;

        ## verify that information exists about both the source and destination
        if (/^s:/) {
            $has_src = 1;
        }
        if (/^d:/) {
            $has_dst = 1;
        }

        ## get source panel type
        if (m{ \A s:([^:]+): }xms) {
            $SRC_PANEL = $1;
        }

        $SRC_PANEL_NOVERSION = $SRC_PANEL;

        if ( $SRC_PANEL and $SRC_PANEL =~ /^cPanel/ ) {
            $SRC_PANEL .= ' source';
            $SRC_PANEL_NOVERSION = 'cPanel source';
        }

        ## so we can print just 'Plesk' to the customer, and not, say, 'Plesk10SMB'
        if ( $SRC_PANEL and $SRC_PANEL =~ /^Plesk/ ) {
            $SRC_PANEL_NOVERSION = 'Plesk';
        }

        ## Panel version info
        if (m{ \A $PANEL_REGEX:VERSION:(.*) }xms) {
            $SRC_PANEL_VERSION = $1;
        }
        elsif (m{ \A d:VERSION:(.*) }xms) {
            $DST_PANEL_VERSION = $1;
        }

        ## OS checks
        if (m{ \A $PANEL_REGEX:OS_DIST:(.*) }xms) {
            $src_os_dist = $1;
        }
        elsif (m{ \A d:OS_DIST:(.*) }xms) {
            $dst_os_dist = $1;
        }
        if (m{ \A $PANEL_REGEX:OS_VERSION:(.*) }xms) {
            $src_os_ver = $1;
        }
        elsif (m{ \A d:OS_VERSION:(.*) }xms) {
            $dst_os_ver = $1;
        }

        ## PHP checks
        if (m{ \A $PANEL_REGEX:PHP:(.*) }xms) {
            $src_php = $1;
        }
        elsif (m{ \A d:PHP:(.*) }xms) {
            $dst_php = $1;
        }

        if (m{ \A d:EA4:(.*) }xms) {
            $dst_ea4 = $1;
        }

        ## MySQL checks
        if (m{ \A $PANEL_REGEX:MYSQL:(.*) }xms) {
            $src_mysql = $1;
        }
        elsif (m{ \A d:MYSQL:(.*) }xms) {
            $dst_mysql = $1;
        }

        ## Bad username checks
        if (m{ \A $PANEL_REGEX:BADUSER:(.*) \z }xms) {
            my $user = $1;

            ## For Ensim
            if ( $user =~ /\^site(\d+)/ ) {
                $user =~ s/\^site(\d+)//g;
            }
            $badusers{$user} = 1;
        }

        ## Bad user config checks
        if (m{ \A $PANEL_REGEX:BAD_USER_CONFIG:(.+):(.+):(.+) \z }xms) {
            my ( $user, $type, $value ) = ( $1, $2, $3 );
            $baduserconfig{$user}{$type} = $value;
        }

        ## Duplicate user/domain checks
        if (m{ \A $PANEL_REGEX:DUPLICATE_USER:(.*):(.*) \z }xms) {
            my ( $user, $domain ) = ( $1, $2 );
            push @{ $dupe_users{$user} }, $domain;
        }
        if (m{ \A $PANEL_REGEX:DUPLICATE_FIRST8:(.*):(.*) \z }xms) {
            my ( $first8, $user ) = ( $1, $2 );
            push @{ $dupe_first8{$first8} }, $user;
        }
        if (m{ \A $PANEL_REGEX:DUPLICATE_DOMAIN:(.*):(.*) \z }xms) {
            my ( $domain, $user ) = ( $1, $2 );
            push @{ $dupe_domains{$domain} }, $user;
        }

        ## IP addr checks
        if (m{ \A $PANEL_REGEX:IPADDRS_USED:(.*) \z }xms) {
            $src_dedicated_ipaddrs_used = $1;
        }
        elsif (m{ \A d:IPADDRS_FREE:(.*) }xms) {
            $dst_ipaddrs_free = $1;
        }

        ## Sites on dedicated IP addrs
        if (m{ \A $PANEL_REGEX:DEDICATED_SITE:(.*) \z }xms) {
            push @sites_on_dedicated_ipaddrs, $1;
        }

        ## Forwarding domains
        if (m{ \A $PANEL_REGEX:FORWARDING_DOMAIN:([^:]+):(.*) }xms) {
            my ( $forwarding_from, $forwarding_to ) = ( $1, $2 );
            $forwarding_domains{$forwarding_from} = $forwarding_to;
        }

        ## No hosting domains
        if (m{ \A $PANEL_REGEX:NOHOSTING_DOMAIN:([^:]+) }xms) {
            my $nohosting_domain = $1;
            push @nohosting_domains, $nohosting_domain;
        }

        ## Tomcat check
        if (m{ \A $PANEL_REGEX:TOMCAT:1 }xms) {
            $src_tomcat = 1;
        }
        if (m{ \A d:TOMCAT:1 }xms) {
            $dst_tomcat = 1;
        }

        ## ColdFusion check
        if (m{ \A $PANEL_REGEX:COLDFUSION:1 }xms) {
            $src_coldfusion = 1;
        }
        if (m{ \A d:COLDFUSION:1 }xms) {
            $dst_coldfusion = 1;
        }

        ## Reseller duplicate username conflict
        # s:Plesk11::RESELLER_CONFLICT:summit
        if (m{ \A $PANEL_REGEX:RESELLER_CONFLICT:(.*) }xms) {
            push @reseller_username_conflicts, $1;
        }

        if (m{ \A $PANEL_REGEX:PHPINI_MEMORY_LIMIT:(\d+) }xms) {
            $src_phpini_memory_limit = length $1 ? $1 : 'NOT SET';
        }
        elsif (m{ \A d:PHPINI_MEMORY_LIMIT:(\d+) }xms) {
            $dst_phpini_memory_limit = length $1 ? $1 : 'NOT SET';
        }

        if (m{ \A $PANEL_REGEX:PHPINI_POST_MAX_SIZE:(\d+) }xms) {
            $src_phpini_post_max_size = length $1 ? $1 : 'NOT SET';
        }
        elsif (m{ \A d:PHPINI_POST_MAX_SIZE:(\d+) }xms) {
            $dst_phpini_post_max_size = length $1 ? $1 : 'NOT SET';
        }

        if (m{ \A $PANEL_REGEX:PHPINI_UPLOAD_MAX_FILESIZE:(\d+) }xms) {
            $src_phpini_upload_max_filesize = length $1 ? $1 : 'NOT SET';
        }
        elsif (m{ \A d:PHPINI_UPLOAD_MAX_FILESIZE:(\d+) }xms) {
            $dst_phpini_upload_max_filesize = length $1 ? $1 : 'NOT SET';
        }

        if (m{ \A $PANEL_REGEX:PHPINI_DATE_TIMEZONE:(.*) }xms) {
            $src_phpini_date_timezone = length $1 ? $1 : 'NOT SET';
        }
        elsif (m{ \A d:PHPINI_DATE_TIMEZONE:(.*) }xms) {
            $dst_phpini_date_timezone = length $1 ? $1 : 'NOT SET';
        }

        if (m{ \A $PANEL_REGEX:PHPINI_OUTPUT_BUFFERING:(.*) }xms) {
            $src_phpini_output_buffering = length $1 ? $1 : 'NOT SET';
        }
        elsif (m{ \A d:PHPINI_OUTPUT_BUFFERING:(.*) }xms) {
            $dst_phpini_output_buffering = length $1 ? $1 : 'NOT SET';
        }

        ## EULA check
        if (m{ \A d:EULA:(\d) }xms) {
            $EULA_ACCEPTED = $1;
        }

        ## mysql username conflict check
        if (m{ \A $PANEL_REGEX:MYSQL_CONFLICT:(.*)\z }xms) {
            push @mysql_username_conflicts, $1;
        }

        ## mysql open_files_limit check
        if (m{ \A d:MYSQL_OPEN_FILES_LIMIT:(\d+)\z }xms) {
            $open_files_limit = $1;
        }

        ## mysql skip-networking check
        if (m{ \A d:MYSQL_SKIP_NETWORKING:1 \z }xms) {
            $skip_networking = 1;
        }

        if (m{ \A $PANEL_REGEX:MYSQL_OLD_STYLE_PASSWORDS:1 \z }xms) {
            $mysql_old_style_passwords = 1;
        }

        if (m{ \A $PANEL_REGEX:DNSCLUSTER:(.*) \z }xms) {
            my $cluster_config = $1;    #host:ip:role
            my ( $cluster_host, $cluster_ip, $cluster_role ) = split /\s*:\s*/, $cluster_config;
            %{ $dns_cluster{$cluster_ip} } = (
                'host' => $cluster_host,
                'role' => $cluster_role,
            );
        }
    }

    close $file_fh;

    if ( not $has_src or not $has_dst ) {
        die "$file is missing information about the source and/or destination servers\n";
    }

    my $src_disk_usage_ref = \@src_disk_usage;
    my $dst_disk_usage_ref = \@dst_disk_usage;

    unless ( $OPTS->{'es'} ) {
        print "Hi,\n\nThe pre migration server evaluation is complete. Our findings are as follows:\n\n";
    }
    else {    #ES
        print "Hola,\n\nLa evaluacin inicial ha completado. Nuestros resultados son los siguientes:\n\n";
    }

    print_parsed_panel_info();
    print_parsed_os_info($dst_os_ver);
    print_parsed_eula_info($EULA_ACCEPTED);
    print_parsed_php_info( $src_php, $dst_php, $dst_ea4 );
    print_parsed_mysql_info( $src_mysql, $dst_mysql );
    print_parsed_bad_username_info(%badusers);
    print_parsed_bad_user_config_info(%baduserconfig);
    print_parsed_duplicate_users( \%dupe_users, \%dupe_first8, \%dupe_domains );
    print_parsed_ipaddr_info( $src_dedicated_ipaddrs_used, $dst_ipaddrs_free, @sites_on_dedicated_ipaddrs );
    print_parsed_forwarding_domain_info(%forwarding_domains);
    print_parsed_nohosting_domain_info(@nohosting_domains);
    print_parsed_tomcat_info( $src_tomcat, $dst_tomcat, $dst_ea4, $dst_os_ver );
    print_parsed_coldfusion_info( $src_coldfusion, $dst_coldfusion );
    print_parsed_reseller_username_conflicts(@reseller_username_conflicts);
    print_parsed_phpini_items(
        $src_phpini_memory_limit,        $dst_phpini_memory_limit,
        $src_phpini_post_max_size,       $dst_phpini_post_max_size,
        $src_phpini_upload_max_filesize, $dst_phpini_upload_max_filesize,
        $src_phpini_date_timezone,       $dst_phpini_date_timezone,
        $src_phpini_output_buffering,    $dst_phpini_output_buffering
    );
    print_parsed_mysql_username_conflicts(@mysql_username_conflicts) if @mysql_username_conflicts;
    print_parsed_mysql_openfileslimit($open_files_limit);
    print_parsed_mysql_skip_networking($skip_networking);
    print_parsed_mysql_old_style_passwords_info( $dst_mysql, $mysql_old_style_passwords );
    print_parsed_dns_clustering_info( \%dns_cluster );
    print "\n";
    return;
}

sub print_parsed_panel_info {
    unless ( $OPTS->{'es'} ) {
        print "Source: " . $SRC_PANEL_VERSION . "\n";
        print "Destination: " . $DST_PANEL_VERSION . "\n";
    }
    else {    #ES
        print "Origen: " . $SRC_PANEL_VERSION . "\n";
        print "Destino: " . $DST_PANEL_VERSION . "\n";
    }
    return;
}

sub print_parsed_os_info {
    my ($dst_os_ver) = @_;
    if ( defined($dst_os_ver) && version_compare( $dst_os_ver, qw( < 6 ) ) ) {
        unless ( $OPTS->{'es'} ) {
            print_header('Operating System Version');
            print "The operating system version on the destination server is not at least major version 6.  Due to various limitations in older operating systems such as the lack of SNI and TLS 1.1/1.2 support we highly recommend that CentOS/RedHat/CloudLinux 6 or 7 is used.\n";
        }
        else {    #ES
            print_header('Versin del sistema operativo');
            print "La versin del sistema operativo en el servidor de destino no es la version minima de 6. Este sistema operativo tiene varias limitaciones tal como la falta de soporte de SNI y TLS 1.1/1.2 debido a esto recomendamos que utilicen CentOS/RedHat/CloudLinux 6 o 7.\n";
        }
    }
    return;
}

sub print_parsed_eula_info {
    if ( $EULA_ACCEPTED == 0 ) {
        unless ( $OPTS->{'es'} ) {
            print_header('cPanel End User License Agreement');
            print "The license agreement has not yet been accepted. Before we can proceed, you must log into WHM as root and accept the license agreement, then complete the initial setup that follows.\n";
        }
        else {    #ES
            print_header('cPanel Licencia');
            print "La licencia de cPanel no ha sido aceptada. Antes de que podamos continuar, por favor acceda a WHM como root y acepte la licencia, inmediatamente despues completen la configuracin inicial que sigue.\n";
        }
    }
    return;
}

sub print_parsed_php_info {
    my ( $src_php, $dst_php, $dst_ea4 ) = @_;
    my %phpver;

    if ( $dst_ea4 eq '1' ) {
        %phpver = (
            major => {
                5 => {
                    minor => {
                        4 => '5.4',
                        5 => '5.5',
                        6 => '5.6'
                    },
                },
                7 => {
                    minor => {
                        0 => '7.0',
                        1 => '7.1'
                    },
                }
            },
            supported    => '5.4, 5.5, 5.6, 7.0, and 7.1',
            supported_es => '5.4, 5.5, 5.6, 7.0, y 7.1'      #ES
        );
    }
    else {
        %phpver = (
            major => {
                5 => {
                    minor => {
                        3 => '5.3',
                        4 => '5.4',
                        5 => '5.5',
                        6 => '5.6'
                    },
                }
            },
            supported    => '5.3, 5.4, 5.5, and 5.6 (using EasyApache 3, PHP 7.0 and 7.1 are available in EasyApache 4)',
            supported_es => '5.3, 5.4, 5.5, y 5.6 (utilizando EasyApache 3. PHP 7.0 and 7.1 son disponibles en EasyApache 4)'    #ES
        );
    }

    my ( $src_php_major, $src_php_minor ) = ( '0', '0' );
    my ( $dst_php_major, $dst_php_minor ) = ( '0', '0' );

    if ( $src_php =~ /^(\d+)\.(\d+)/ ) {
        ( $src_php_major, $src_php_minor ) = ( $1, $2 );
    }

    if ( $dst_php =~ /^(\d+)\.(\d+)/ ) {
        ( $dst_php_major, $dst_php_minor ) = ( $1, $2 );
    }

    my $print_message = 0;
    my $addendum;

    return if ( $src_php eq $dst_php );

    ## If source isn't using supported PHP
    if ( !exists( $phpver{major}->{$src_php_major}->{minor}->{$src_php_minor} ) ) {
        $print_message = 1;
        $addendum .= "\n";
        unless ( $OPTS->{'es'} ) {
            $addendum .= "The ${SRC_PANEL_NOVERSION} server appears to be running an unsupported version of PHP[1].  cPanel currently supports PHP $phpver{supported}.  Unfortunately, there may be issues with your sites displaying correctly on a supported PHP version.\n\n";
            $addendum .= "We can definitely move forward with the migration. However, we would be unable to determine if any of your PHP driven websites may be incompatible with the supported versions of PHP. We highly recommend that any PHP based websites are updated (if necessary) to be compatible with a supported version of PHP.\n\n";
            $addendum .= "Additionally, after the migration, we may not be able to provide assistance for issues related to websites which require an unsupported version of PHP.\n\n";
        }
        else {    #ES
            $addendum .= "El servidor ${SRC_PANEL_NOVERSION} parece estar corriendo una version de PHP[1] que no es soportado. cPanel actualmente soporta PHP $phpver{supported_es}. Desafortunadamente, pueden haber problemas con sus sitios siendo procesados correctamente al usar una version soportada de PHP.\n\n";
            $addendum .= "Definitivamente podemos proceder con esta migracion. Sin embargo, no podremos determinar si alguno de su sitios utilizando PHP son incompatibles con la version soportadas de PHP. Recomendamos que cualquier sitio que use PHP sea actualizado(si es necesario) a una version soportada de PHP.\n\n";
            $addendum .= "Adicionalmente, no podremos proveer asistencia a problemas relacionados con sus sitios que requieran una version no soportada de PHP.\n\n";
        }
        $addendum .= "[1] http://php.net/eol.php\n";
    }

    ## if dest cPanel isn't using supported PHP for some reason
    if ( !exists( $phpver{major}->{$dst_php_major}->{minor}->{$dst_php_minor} ) ) {
        $print_message = 1;
        unless ( $OPTS->{'es'} ) {
            $addendum .= "The cPanel destination server appears to be running an unsupported version of PHP.  Only PHP $phpver{supported} are supported at this time. If you have elected to have us reconfigure PHP to add support for certain PHP modules, we will be unable to do so unless we can install a supported version of PHP.\n\n";
            $addendum .= "Would you like us to install one of the supported PHP versions on the cPanel destination server? If yes, which version? If no version is specified, we will use the latest available.\n\n";
            $addendum .= "Please note that this will most likely result in the unsupported version of PHP being removed and it may not be possible to reverse the change.\n\n";
            $addendum .= "[ ] YES   [ ] NO\n";
        }
        else {    #ES
            $addendum .= "El servidor de Destino de cPanel aparece estar corriendo una versin de PHP que ya no es soportado. Solamente PHP $phpver{supported_es} es soportado en este momento. Si usted ha elegido que nosotros re-configuremos PHP para agregar soporte de ciertos mdulos de PHP no podremos hacerlo a menos que podamos instalar una versin soportada de PHP.\n\n";
            $addendum .= "Quiere que instalemos una de las versiones de PHP soportados en el servidor de Destino de cPanel? Si, la respuesta es si. Que versin? Si ninguna versin es especificada usaremos la ultima versin disponible.\n\n";
            $addendum .= "Por favor tomen en cuenta que esto resultara en la version no soportada de PHP siendo removido del servidor y muy probablemente no podremos revertir este cambio.\n\n";
            $addendum .= "[ ] SI   [ ] NO\n";
        }
    }

    if ( $print_message == 1 ) {
        unless ( $OPTS->{'es'} ) {
            print_header('PHP Versions');
        }
        else {    #ES
            print_header('Versiones de PHP');
        }
        print $SRC_PANEL_NOVERSION . ': ' . $src_php . "\n";
        print 'cPanel: ' . $dst_php . "\n";
        print "\n" . $addendum;
    }
    return;
}

sub print_parsed_mysql_info {
    my ( $src_mysql, $dst_mysql ) = @_;

    my $print_message = 0;
    my $addendum;

    if ( $src_mysql =~ m{ (.*):UNSUPPORTED }xms ) {
        $src_mysql =~ s/:UNSUPPORTED//g;

        $print_message = 1;
        $addendum .= "\n";
        unless ( $OPTS->{'es'} ) {
            $addendum .= "The ${SRC_PANEL_NOVERSION} server is running MySQL ${src_mysql}. This version is not supported at this time. We can attempt the migration anyway, but you may need to create the databases on the cPanel destination server, then manually export and import your databases.\n\n";
            $addendum .= "Would you like us to proceed with the migration anyway?\n\n";
            $addendum .= "[ ] YES  [ ] NO\n";
        }
        else {    # ES
            $addendum .= "El servidor ${SRC_PANEL_NOVERSION} est utiliza MySQL ${src_mysql}. Esta versin no es soportado en estos momentos. Podemos intentar continuar con la migracin, pero usted tendra que crear las bases de datos en el servidor de cPanel, despues manualmente exportar e importar sus bases de datos.\n\n";
            $addendum .= "Quieres que procedamos con la migracin?\n\n";
            $addendum .= "[ ] SI   [ ] NO\n";
        }

        if ( $dst_mysql =~ /^4/ ) {
            $addendum .= "\nThe cPanel destination server is running MySQL 4, which is not supported at this time. Our recommendation would be to upgrade MySQL via WHM >> MySQL Upgrade before we proceed further.\n";
        }
    }

    if ( $print_message == 1 ) {
        unless ( $OPTS->{'es'} ) {
            print_header('MySQL Versions');
        }
        else {    #ES
            print_header('Versiones MySQL');
        }
        print $SRC_PANEL_NOVERSION . ': ' . $src_mysql . "\n";
        print "cPanel: $dst_mysql\n";
        print $addendum ;
    }
    return;
}

sub print_parsed_bad_username_info {
    my %badusers = @_;

    return if !%badusers;

    # get panel version. print how to change username based on panel version

    unless ( $OPTS->{'es'} ) {
        print_header('Incompatible Usernames');
        print "Usernames were found on the ${SRC_PANEL_NOVERSION} server that are not compatible with the cPanel destination server. You will need to rename those users before we can copy them. A list of these users is as follows:\n\n";
    }
    else {    #ES
        print_header('Malos nombres de usuario');
        print "Los nombres de los usuarios que se encuentran en el servidor de ${SRC_PANEL_NOVERSION} no son compatibles con el servidor de Destino de cPanel. Usted tendr que cambiar el nombre de los usuarios antes de que podamos copiarlos. La lista de estos usuarios son:\n\n";
    }

    for my $user ( sort keys %badusers ) {
        print "* " . $user . "\n";
    }

    print "\n";
    unless ( $OPTS->{'es'} ) {
        print_username_change_info();
    }
    else {
        print_username_change_info_ES();
    }
    return;
}

sub print_parsed_bad_user_config_info {
    my %baduserconfig = @_;
    return if !%baduserconfig;
    unless ( $OPTS->{'es'} ) {
        print_header('User configuration issues');
        print "Some user configuration problems were found on the ${SRC_PANEL_NOVERSION} server that may cause failues during the transfer process.  You will need to correct these configuration issues before we can copy these users.  A list of these users and configuration problems is as follows:\n\n";
        print "USERNAME: PROBLEM DESCRIPTION\n";
        print "-----------------------------\n";
    }
    else {    #ES
        print_header('Problemas de configuracion de usuarios');
        print "Hemos encontrado algunos problemas de configuracin en el servidor de ${SRC_PANEL_NOVERSION} que pueden causar problemas durante el proceso de transferencia. Ustedes necesitaran corregir estos problemas de configuracin antes de que podamos copiar estos usuarios. La lista de usuarios y los problemas de configuracin son los siguientes:\n\n";
        print "USUARIO: DESCRIPCION\n";
        print "--------------------\n";
    }
    my %problem = (
        'QUOTA_EN'     => 'The user\'s "Total Disk Space(MB)" value must be numeric, with no suffix added such as "MB" or "GB". The current value is: ',
        'QUOTA_ES'     => 'El valor del usuario "Total Disk Space(MB)" debe ser numerico sin ningn sufijo agregado como "MB" o "GB". El valor actual es: ',    #ES
        'BANDWIDTH_EN' => 'The user\'s "Bandwidth (MB)" value must be numeric, with no suffix added such as "MB" or "GB". The current value is: ',
        'BANDWIDTH_ES' => 'El valor del usuario "Bandwidth (MB)" debe ser numerico sin ningn sufijo agregado como "MB" o "GB". El valor actual es: ',          #ES
    );
    print "\n";
    for my $user ( sort keys %baduserconfig ) {
        for my $type ( sort keys %{ $baduserconfig{$user} } ) {
            my $type_lang = $type . ( $OPTS->{'es'} ? "_ES" : "_EN" );
            print $user . ": " . $problem{$type_lang} . $baduserconfig{$user}{$type} . "\n\n";
        }
    }
    return;
}

sub print_parsed_duplicate_users {
    my ( $dupe_users, $dupe_first8, $dupe_domains ) = @_;
    my $print_dupes = sub {
        my ( $href, $pp ) = @_;
        $pp = defined($pp) ? $pp : '';
        for my $key ( sort keys %{$href} ) {
            for my $dupe ( sort @{ $href->{$key} } ) {
                print $pp . $key . ': ' . $dupe . "\n";
            }
        }
    };

    if ( scalar keys %{$dupe_users} ) {
        unless ( $OPTS->{'es'} ) {
            print_header('Duplicate usernames');
            print "Some duplicated user names were found on the ${SRC_PANEL_NOVERSION} server.  Please rename these users so that they will not cause a conflict during transfer:\n\n";
            print "USERNAME: DOMAIN\n";
            print "----------------\n";
        }
        else {    #ES
            print_header('Nombres de usuarios duplicados');
            print "Se han encontrado nombres de usuarios duplicados en el servidor ${SRC_PANEL_NOVERSION}. Por favor cambie el nombre de estos usuarios para que no haya un conflicto durante la transferencia:\n\n";
            print "USUARIO: DOMINIO\n";
            print "----------------\n";
        }
        &$print_dupes($dupe_users);
    }

    if ( scalar keys %{$dupe_first8} ) {
        unless ( $OPTS->{'es'} ) {
            print_header('First 8 characters of username are not unique');
            print "Database prefixing in WHM/cPanel requires the first 8 characters of each username to be unique, please rename the following users on the ${SRC_PANEL_NOVERSION} server to prevent a conflict during transfer:\n\n";
            print "FIRST_8: FULL_USERNAME (DOMAIN)\n";
            print "-------------------------------\n";
        }
        else {    #ES
            print_header('Los primeros 8 caracteres del nombre de usuario no son nicos');
            print "Prefijo de base de datos en WHM/cPanel requiere que los primeros 8 caracteres de cada nombre de usuario sea nico, por favor, cambie el nombre de los siguientes usuarios en el servidor de ${SRC_PANEL_NOVERSION} para evitar un conflicto durante la transferencia:\n\n";
            print "PRIMEROS_8: USUARIO_COMPLETO (DOMINIO)\n";
            print "--------------------------------------\n";
        }
        &$print_dupes($dupe_first8);
    }

    if ( scalar keys %{$dupe_domains} ) {
        unless ( $OPTS->{'es'} ) {
            print_header('Same domain owned by multiple users');
            print "The same domain was found to be owned by multiple users which will result in a domain conflict during transfer.  Please ensure that each domain is only associated with one user on the ${SRC_PANEL_NOVERSION} server:\n\n";
            print "DOMAIN: USERNAME\n";
            print "----------------\n";
        }
        else {    #ES
            print_header('Multiples usuarios son dueos del mismo dominio');
            print "El mismo dominio fue encontrado ser posedo por varios usuarios lo cual causara un conflicto de dominio durante la transferencia. Asegrese de que cada dominio solamente est asociado a un usuario dentro del servidor de ${SRC_PANEL_NOVERSION}:\n\n";
            print "DOMINIO: USUARIO\n";
            print "----------------\n";
        }
        &$print_dupes($dupe_domains);
    }
    return;
}

sub print_reseller_username_change_info {

    # This has only been tested on Plesk 10, 11, and 11.5.
    unless ( $OPTS->{'es'} ) {
        print "1. Log into Plesk as admin\n";
        print "2. Click 'Resellers'\n";
        print "3. Click the link under the 'Reseller Name' column\n";
        print "4. Click 'Change Login Info'\n";
    }
    else {    #ES
        print "1. Inicie sesin en Plesk como 'admin'\n";
        print "2. Haga clic en 'Resellers'\n";
        print "3. Haga clic en el enlace debajo de la columna 'Reseller Name'\n";
        print "4. Haga clic en 'Change Login Info'\n";
    }
    return;
}

sub print_username_change_info {
    print "When renaming the users, please use the following guidelines:\n\n";
    print "* Use only letters (lowercase only), and numbers if desired\n";
    print "* Users cannot start with a number, or with the string 'test'\n";

    if ( $SRC_PANEL_NOVERSION =~ /Plesk/ ) {
        print "\nYou can change usernames using these steps:\n\n";

        if ( $SRC_PANEL eq 'Plesk8' ) {
            print "1. Log into Plesk as 'admin'\n";
            print "2. Click 'Domains'\n";
            print "3. Click on the domain\n";
            print "4. Click on 'Setup'\n";
        }
        elsif ( $SRC_PANEL eq 'Plesk9' ) {
            print "1. Log into Plesk as 'admin'\n";
            print "2. Click 'Domains'\n";
            print "3. Click on the domain\n";
            print "4. Click on 'Web Hosting Settings'\n";
        }
        elsif ( $SRC_PANEL eq 'Plesk10' ) {
            print "1. Log into Plesk as 'admin'\n";
            print "2. Click 'Domains'\n";
            print "3. Click on the domain\n";
            print "4. Click on 'Change Hosting Settings'\n";
        }
        elsif ( $SRC_PANEL eq 'Plesk10SMB' ) {
            print "1. Log into Plesk as 'admin'\n";
            print "2. Click 'Websites & Domains'\n";
            print "3. Click 'Website Settings'\n";
            print "4. Change the value in the box labeled 'FTP username'\n";
        }
        else {    # Plesk 11+
            print "1. Log into Plesk as 'admin'\n";
            print "2. Click 'Domains'\n";
            print "3. Click on the domain\n";
            print "4. Click the 'General' tab\n";
            print "5. Click 'Change Hosting Settings'\n";
        }
    }
    elsif ( $SRC_PANEL =~ /Ensim/ ) {
        print "1. Log into Ensim as 'admin'\n";
        print "2. Click 'Site Manager'\n";
        print "3. On the line that contains the domain, click the pencil icon to edit\n";
    }
    return;
}

sub print_username_change_info_ES {    #ES
    print "Cuando cambie el nombre de los usuarios, por favor siga las siguientes directivas:\n\n";
    print "* Utilice solamente letras (solamente minsculas), y nmeros\n";
    print "* Nombres de usuario no pueden comenzar con un nmero o con el string 'test'\n";

    if ( $SRC_PANEL_NOVERSION =~ /Plesk/ ) {
        print "\n";
        print "Usted puede cambiar los nombres de los usuarios siguiendo las siguiente instrucciones:\n\n";
        if ( $SRC_PANEL eq 'Plesk8' ) {
            print "1. Inicie sesin en Plesk como 'admin'\n";
            print "2. Haga clic en 'Domains'\n";
            print "3. Haga clic en el dominio\n";
            print "4. Haga clic en 'Setup'\n";
        }
        elsif ( $SRC_PANEL eq 'Plesk9' ) {
            print "1. Inicie sesin en Plesk como 'admin'\n";
            print "2. Haga clic en 'Domains'\n";
            print "3. Haga clic en el dominio\n";
            print "4. Haga clic en 'Web Hosting Settings'\n";
        }
        elsif ( $SRC_PANEL eq 'Plesk10' ) {
            print "1. Inicie sesin en Plesk como 'admin'\n";
            print "2. Haga clic en 'Domains'\n";
            print "3. Haga clic en el dominio\n";
            print "4. Haga clic en 'Change Hosting Settings'\n";
        }
        elsif ( $SRC_PANEL eq 'Plesk10SMB' ) {
            print "1. Inicie sesin en Plesk como 'admin'\n";
            print "2. Haga clic en 'Websites & Domains'\n";
            print "3. Haga clic en 'Website Settings'\n";
            print "4. Cambie el valor en la casilla 'FTP username'\n";
        }
        else {    # Plesk 11+
            print "1. Inicie sesin en Plesk como 'admin'\n";
            print "2. Haga clic en 'Domains'\n";
            print "3. Haga clic en el dominio\n";
            print "4. Haga click en la ficha 'General'\n";
            print "5. Haga clic en 'Change Hosting Settings'\n";
        }
    }
    elsif ( $SRC_PANEL =~ /Ensim/ ) {
        print "\n";
        print "1. Inicie sesin en Ensim como 'admin'\n";
        print "2. Haga clic en 'Site Manager'\n";
        print "3. En la lnea que contiene el dominio, haga clic en el icono del lpiz para editar\n";
    }
    return;
}

sub print_parsed_ipaddr_info {
    my ( $src_dedicated_ipaddrs_used, $dst_ipaddrs_free, @sites_on_dedicated_ipaddrs ) = @_;

    if ( $src_dedicated_ipaddrs_used > $dst_ipaddrs_free ) {
        unless ( $OPTS->{'es'} ) {
            print_header('IP Addresses');
            print "On the ${SRC_PANEL_NOVERSION} server, the following sites are on dedicated IP addresses:\n";
        }
        else {    #ES
            print_header('Direcciones IP');
            print "En el servidor de ${SRC_PANEL_NOVERSION}, los siguientes sitios tienen direcciones IP dedicadas:\n";
        }

        print "\n\n";
        for my $site ( sort @sites_on_dedicated_ipaddrs ) {
            print "* $site\n";
        }

        unless ( $OPTS->{'es'} ) {
            print "\n\nHowever, the cPanel destination server has $dst_ipaddrs_free dedicated IP address(es) available.\n\n";
            print "If the sites listed above need to be placed on dedicated IP addresses, you may need to contact your server provider about adding more IP addresses to your server.\n\n";
            print "If you are using cPanel 11.38 or higher on an OS with SNI support (such as CentOS 6), then you may not need any additional IP addresses. Please check with your server provider to be sure.\n\n";
            print "Do you need us to place those sites on dedicated IP addresses?\n\n";
            print "[ ] YES   [ ] NO\n";
        }
        else {    #ES
            print "\n\nSin embargo, el servidor cPanel tiene $dst_ipaddrs_free IP dedicado(s) disponible(s).\n\n";
            print "Si los sitios mencionados anteriormente deben ser colocados en direcciones IP dedicadas, puede que usted tenga que ponerse en contacto con su proveedor de servidor acerca de cmo agregar ms direcciones IP a su servidor.\n\n";
            print "Si est utilizando cPanel 11.38 o mayor en un sistema operativo con soporte SNI (como CentOS 6), entonces puede que no necesite ninguna de las direcciones IP adicionales. Por favor, consulte con su proveedor de servidor para estar seguro.\n\n";
            print "Necesitas que estos sitios tengan direcciones IP dedicadas?\n\n";
            print "[ ] SI   [ ] NO\n";
        }
    }
    return;
}

sub print_parsed_forwarding_domain_info {
    my %forwarding_domains = @_;

    return if !%forwarding_domains;

    unless ( $OPTS->{'es'} ) {
        print_header('Forwarding Domains');
        print "We cannot transfer the following forwarding domains, as they are not hosting accounts.\n";
        print "You can add them in WHM >> Setup/Edit Domain Forwarding (this requires just 1 additional IP address on the cPanel destination server if one does not exist already):\n";
    }
    else {    #ES
        print_header('Dominios reenviar');
        print "No podemos transferir los siguientes forwarding domains, ya que no son cuentas de hosting.\n";
        print "Usted puede aadirlos en WHM >> Setup/Edit Domain Forwarding (esto requiere slo 1 direccin IP adicional en el servidor de cPanel si es que uno no existe):\n";
    }

    print "\n";
    for my $domain ( sort keys %forwarding_domains ) {
        unless ( $OPTS->{'es'} ) {
            print "${domain}: forwarded to -> $forwarding_domains{$domain}\n";
        }
        else {    #ES
            print "${domain}: remitido a -> $forwarding_domains{$domain}\n";
        }
    }
    return;
}

sub print_parsed_nohosting_domain_info {
    my @nohosting_domains = @_;
    return if !@nohosting_domains;

    unless ( $OPTS->{'es'} ) {
        print_header('No Hosting domains');
        print "The following are domains that we have found that do not have a hosting plan.\n";
        print "The cPanel & WHM transfer tools will not be able to transfer these domains.\n";
        print "You can try converting these to hosting domains by using a command such as this:\n";
        print "   /usr/local/psa/bin/domain --update domain.tld -hst_type phys -hosting true\n";
        print "You can also use Plesk Control Panel > Websites & Domains, select the domain name, then Hosting Type > Change.\n";
        print "In order to make them compatible with the transfer tools, please add hosting to these domains:\n";
    }
    else {    #ES
        print_header('Dominios sin hosting');
        print "Los siguientes son dominios que hemos encontrado que no tienen un plan de hosting.\n";
        print "Las herramientas de transferencia de cPanel y WHM no sern capaces de transferir estos dominios.\n";
        print "Con el fin de hacerlos compatibles con las herramientas de transferencia, por favor agregue un plan de hosting a estos dominios:\n";
    }

    print "\n";
    for my $domain ( sort @nohosting_domains ) {
        print "* $domain\n";
    }
    return;
}

sub print_parsed_tomcat_info {
    my ( $src_tomcat, $dst_tomcat, $dst_ea4, $dst_os_ver ) = @_;

    if ( $src_tomcat and not $dst_tomcat ) {
        print_header('Tomcat');
        if ( $dst_ea4 || version_compare( $dst_os_ver, qw( >= 7 ) ) ) {
            unless ( $OPTS->{'es'} ) {
                print "Tomcat is installed on the ${SRC_PANEL_NOVERSION} server, but is not supported on the cPanel destination server due to OS and/or EasyApache 4 incompatibility.\n";
            }
            else {    #ES
                print "Tomcat esta instalado en el ${SRC_PANEL_NOVERSION} server, pero esto no es soportado en el servidor de cPanel debido a una incompatibilidad con el Sistema Operativo y/o EasyApache 4.\n";
            }
        }
        else {        # EA3 and CentOS <= 6
            unless ( $OPTS->{'es'} ) {
                print "Tomcat is installed on the ${SRC_PANEL_NOVERSION} server, but not on the cPanel destination server.\n\n";
                print "Do you need us to install Tomcat on the cPanel destination server?\n\n";
                print "[ ] YES  [ ] NO\n";
            }
            else {    #ES
                print "Tomcat est instalado en el servidor ${SRC_PANEL_NOVERSION}, pero no en el servidor cPanel.\n\n";
                print "Necesiten que instalemos Tomcat en el servidor de cPanel?\n\n";
                print "[ ] SI   [ ] NO\n";
            }
        }
    }
    return;
}

sub print_parsed_coldfusion_info {
    my ( $src_coldfusion, $dst_coldfusion ) = @_;

    if ( $src_coldfusion and not $dst_coldfusion ) {
        print_header('ColdFusion');
        unless ( $OPTS->{'es'} ) {
            print "ColdFusion appears to be running on the ${SRC_PANEL_NOVERSION} server, but not on the cPanel destination server.\n\n";
            print "cPanel does not support the installation, configuration, or maintenance of ColdFusion.\n\n";
            print "If your websites require ColdFusion, they will not work if it is not installed.\n\n";
            print "If you need assistance with installing ColdFusion, you would need to contact your sysadmin.\n";
        }
        else {    #ES
            print "ColdFusion parece estar en ejecucin en el servidor ${SRC_PANEL_NOVERSION}, pero no en el servidor cPanel.\n\n";
            print "cPanel does not support the installation, configuration, or maintenance of ColdFusion.\n\n";
            print "Si sus pginas web requieren ColdFusion, no van a funcionar si no est instalado.\n\n";
            print "Si usted necesita ayuda con la instalacin de ColdFusion, usted tendra que ponerse en contacto con su administrador de sistemas.\n";
        }
    }
    return;
}

sub print_parsed_reseller_username_conflicts {
    my @reseller_username_conflicts = @_;
    return if !@reseller_username_conflicts;

    @reseller_username_conflicts = sort @reseller_username_conflicts;

    unless ( $OPTS->{'es'} ) {
        print_header('Reseller Username Conflicts');
        print "Plesk allows duplicate usernames for resellers and system accounts, while cPanel does not.\n\n";
        print "As such, the following usernames will need to be renamed to something unique before they can be copied:\n\n";
    }
    else {    #ES
        print_header('Conflictos de Nombre de usuarios de revendedores');
        print "Plesk permite los nombres de usuario duplicados para los revendedores y las cuentas del sistema, mientras que cPanel no lo hace.\n\n";
        print "Como tal, tendr que ser cambiado a algo nico antes de que se pueden copiar los siguientes nombres de usuario:\n\n";
    }

    for my $reseller (@reseller_username_conflicts) {
        print "* $reseller\n";
    }
    print "\n";
    print_reseller_username_change_info();
    return;
}

sub print_parsed_mysql_openfileslimit {
    my $open_files_limit = shift or return;

    if ( $open_files_limit < 10_000 ) {
        print_header('MySQL open_files_limit');
        unless ( $OPTS->{'es'} ) {
            print "On the cPanel destination server, MySQL's open_files_limit is set to $open_files_limit which may be lower than what is necessary to successfully copy databases.\n\n";
            print "I recommend increasing this to 10000 and restarting MySQL. If you'd like, we can do this for you by backing up /etc/my.cnf, adding open_files_limit=10000 to the file, and restarting MySQL.\n\n";
            print "May we raise the open_files_limit setting for MySQL?\n\n";
            print "[ ] YES  [ ] NO\n";
        }
        else {    #ES
            print "Los open_files_limit de MySQL en el servidor cPanel tienen el valor de 1024. Este valor es menos de lo que recomendamos , que puede ser inferior a lo que es necesario copiar correctamente las bases de datos.\n\n";
            print "Recomiendo aumentar esto a 10000 y reiniciar MySQL. Si usted desea, podemos hacerlo para usted antes haramos una copia de /etc/ my.cnf, aadiendo open_files_limit = 10000 para el archivo y reiniciaremos  MySQL.\n\n";
            print "Podemos aumentar el ajuste de open_files_limit para MySQL?\n\n";
            print "[ ] SI  [ ] NO\n";
        }
    }
    return;
}

sub print_parsed_mysql_skip_networking {
    my $skip_networking = shift;
    return unless $skip_networking;

    print_header('MySQL skip_networking');
    unless ( $OPTS->{'es'} ) {
        print "On the cPanel destination server, MySQL's skip_networking option is enabled. This can prevent databases from restoring properly. This option needs to be disabled throughout the migration process.\n\n";
        print "May we disable MySQL's skip_networking setting on the cPanel destination server?\n\n";
        print "[ ] YES  [ ] NO\n";
    }
    else {    # ES
        print "En el servidor de cPanel, est habilitada la opcin skip_networking de MySQL. Esto puede impedir que las bases de datos se puedan restaurar correctamente. Esta opcin debe ser deshabitado durante todo el proceso de migracin.\n\n";
        print "Podemos desactivar la opcin de skip_networking de MySQL en el servidor cPanel?\n\n";
        print "[ ] SI  [ ] NO\n";
    }
    return;
}

sub print_parsed_mysql_old_style_passwords_info {
    my ( $cpanel_mysql_version, $mysql_old_style_passwords ) = @_;
    $cpanel_mysql_version =~ s/\.//g;
    $cpanel_mysql_version = substr $cpanel_mysql_version, 0, 2;

    if ( defined $mysql_old_style_passwords == 1 and $cpanel_mysql_version >= 56 ) {
        unless ( $OPTS->{'es'} ) {
            print_header('MySQL 5.6 and old_passwords=1');
            print "The ${SRC_PANEL_NOVERSION} server is using the 'old_passwords=1' option. However, the cPanel destination server is using MySQL 5.6 or later. These are not compatible. The only known workarounds at this time are:\n\n";
            print "1) Set up a cPanel destination server with MySQL 5.1 or 5.5, OR\n";
            print "2) Disable the old_passwords=1 option for MySQL on the ${SRC_PANEL_NOVERSION} server and reapply all of the MySQL users' passwords. Then verify the mysql.user table contains the new style passwords for each user.\n";
        }
        else {
            print_header('MySQL 5.6 y old_passwords=1');
            print "El servidor ${SRC_PANEL_NOVERSION} est utilizando la opcin 'old_passwords=1'. Sin embargo, el servidor cPanel esta usando MySQL 5.6. Estos no son compatibles. Las soluciones conocidas solamente en este momento son:\n\n";
            print "1) Configurar un servidor cPanel con MySQL 5.1 o 5.5, o\n";
            print "2) Deshabilitar los old_passwords=1 opcin para MySQL en el servidor ${SRC_PANEL_NOVERSION} y vuelva a aplicar todas las contraseas de los usuarios MySQL. Compruebe en el mysql.user contiene las nuevas contraseas de estilo para cada usuario.\n";
        }
    }
    return;
}

sub print_parsed_phpini_items {    ## no critic (ManyArgs)
    my (
        $src_phpini_memory_limit,        $dst_phpini_memory_limit,
        $src_phpini_post_max_size,       $dst_phpini_post_max_size,
        $src_phpini_upload_max_filesize, $dst_phpini_upload_max_filesize,
        $src_phpini_date_timezone,       $dst_phpini_date_timezone,
        $src_phpini_output_buffering,    $dst_phpini_output_buffering
    ) = @_;

    my $addendum;

    if ( $src_phpini_memory_limit and $dst_phpini_memory_limit ) {
        if ( $src_phpini_memory_limit > $dst_phpini_memory_limit ) {
            $addendum .= "\nmemory_limit:\n";
            $addendum .= "    ${SRC_PANEL_NOVERSION}: ${src_phpini_memory_limit}M\n";
            $addendum .= "    cPanel: ${dst_phpini_memory_limit}M\n";
        }
    }

    if ( $src_phpini_post_max_size and $dst_phpini_post_max_size ) {
        if ( $src_phpini_post_max_size > $dst_phpini_post_max_size ) {
            $addendum .= "\npost_max_size:\n";
            $addendum .= "    ${SRC_PANEL_NOVERSION}: ${src_phpini_post_max_size}M\n";
            $addendum .= "    cPanel: ${dst_phpini_post_max_size}M\n";
        }
    }

    if ( $src_phpini_upload_max_filesize and $dst_phpini_upload_max_filesize ) {
        if ( $src_phpini_upload_max_filesize > $dst_phpini_upload_max_filesize ) {
            $addendum .= "\nupload_max_filesize:\n";
            $addendum .= "    ${SRC_PANEL_NOVERSION}: ${src_phpini_upload_max_filesize}M\n";
            $addendum .= "    cPanel: ${dst_phpini_upload_max_filesize}M\n";
        }
    }

    if ( $src_phpini_date_timezone and $dst_phpini_date_timezone ) {
        if ( $src_phpini_date_timezone ne $dst_phpini_date_timezone ) {
            $addendum .= "\ndate.timezone:\n";
            $addendum .= "    ${SRC_PANEL_NOVERSION}: ${src_phpini_date_timezone}\n";
            $addendum .= "    cPanel: ${dst_phpini_date_timezone}\n";
        }
    }

    if ( $src_phpini_output_buffering and $dst_phpini_output_buffering ) {
        if ( $src_phpini_output_buffering ne $dst_phpini_output_buffering ) {
            $addendum .= "\noutput_buffering:\n";
            $addendum .= "    ${SRC_PANEL_NOVERSION}: ${src_phpini_output_buffering}\n";
            $addendum .= "    cPanel: ${dst_phpini_output_buffering}\n";
        }
    }

    if ($addendum) {
        unless ( $OPTS->{'es'} ) {
            print_header('php.ini Settings');
            print "We have checked several of the most commonly customized configuration options in php.ini and found some differences.\n\n";
            print "To ensure that PHP applications function properly on the cPanel destination server, it is recommended that the settings be the same on both servers.\n\n";
            print "The differences that we found are listed below:\n";
            print $addendum . "\n";
            print "Would you like us to modify php.ini on the cPanel destination server to use the same configuration settings listed above?\n\n";
            print "[ ] YES  [ ] NO\n";
        }
        else {    #ES
            print_header('Configuracin php.ini');
            print "Hemos revisado varias de las opciones de configuracin ms comnmente personalizados en php.ini y encontramos algunas diferencias.\n\n";
            print "Para asegurarse de que las aplicaciones PHP funcionan correctamente en el servidor de cPanel, se recomienda que los ajustes sean los mismos en ambos servidores.\n\n";
            print "Las diferencias encontradas se enumeran a continuacin:\n\n";
            print $addendum . "\n";
            print "Quieres que modifiquemos php.ini en el servidor cPanel utilizar los mismos ajustes de configuracin mencionados anteriormente?\n\n";
            print "[ ] SI  [ ] NO\n";
        }
    }
    return;
}

sub print_htype_fwd {
    return unless $IS_PLESK or $IS_PLESK_SMB10;

    my @htype_fwd = `mysql psa -Be 'SELECT domains.name, domains.htype AS hosttype, forwarding.redirect AS target FROM domains, forwarding WHERE domains.id = forwarding.dom_id'`;
    if (@htype_fwd) {
        for my $line (@htype_fwd) {
            chomp $line;
            $line =~ s#/$##g;
            if ( $line =~ m{ \A (\S+) \s (?:std|frm)_fwd \s (\S+) \z }xms ) {
                my $forward = "${1}: forwarded to -> $2";
                push @HOSTING_TYPE_FORWARD, $forward;
            }
        }
    }

    if (@HOSTING_TYPE_FORWARD) {
        print "\nForwarded domains:\n";
        for my $line (@HOSTING_TYPE_FORWARD) {
            print "$line\n";
        }
    }
    return;
}

sub print_htype_none {
    return unless $IS_PLESK or $IS_PLESK_SMB10;

    my @htype_none = `mysql psa -Be 'SELECT domains.name, domains.htype AS hosting FROM domains WHERE htype = "none"'`;
    if (@htype_none) {
        for my $line (@htype_none) {
            chomp $line;
            if ( $line =~ m{ \A (\S+) \s+ none \z }xms ) {
                push @HOSTING_TYPE_NOHOSTING, $1;
            }
        }
    }

    if (@HOSTING_TYPE_NOHOSTING) {
        print "\nNo hosting domains:\n";
        for my $line (@HOSTING_TYPE_NOHOSTING) {
            print "$line\n";
        }
    }
    return;
}

sub print_parsed_mysql_username_conflicts {
    my @mysql_username_conflicts = @_;
    my $count                    = 1;
    unless ( $OPTS->{'es'} ) {
        print_header('mysql Username Conflicts');
        print "MySQL username conflicts have been found. To fix, please rename the user(s) specified below:\n\n";
    }
    else {    #ES
        print_header('conflictos de nombre de usuario mysql');
        print "Se han encontrado conflictos con nombre(s) de usuario(s) de MySQL. Para solucionarlo, cambie el nombre del usuario(s):\n\n";
    }

    for my $conflict (@mysql_username_conflicts) {
        my ( $domain1, $user, $domain2 ) = split /:/, $conflict;

        # subscription1.test has mysql user "example", but there is a Plesk account named example, owned by example.com
        unless ( $OPTS->{'es'} ) {
            print "[CONFLICT $count] $domain1 has mysql user \"$user\" (to fix, rename ${domain2}'s \"$user\")\n";
        }
        else {    #ES
            print "[CONFLICTO $count] $domain1 tiene el usuario mysql \"$user\" (para corregir, cambie el nombre ${domain2}'s \"$user\")\n";
        }
        $count++;
    }

    print "\n";
    unless ( $OPTS->{'es'} ) {
        print_username_change_info();
    }
    else {
        print_username_change_info_ES();
    }
    return;
}

sub print_parsed_dns_clustering_info {
    my ($dns_cluster_href) = @_;
    return unless %{$dns_cluster_href};

    unless ( $OPTS->{'es'} ) {
        print_header('DNS CLUSTERING');
        print "NOTE: THIS SECTION ONLY APPLIES IF THE SOURCE SERVER IS COMPROMISED\n\n";
        print "If the source server has been root compromised, any DNS Cluster access keys or API tokens may also be compromised and should be changed.\n\n";
        print "The following cluster members were found to be configured on the source server:\n\n";
        print "HOSTNAME - IP\n";
        print "-------------\n";
    }
    else {    #ES
        print_header('DNS CLUSTERING');
        print "NOTE: THIS SECTION ONLY APPLIES IF THE SOURCE SERVER IS COMPROMISED\n\n";
        print "If the source server has been root compromised, any DNS Cluster access keys or API tokens may also be compromised and should be changed.\n\n";
        print "The following cluster members were found to be configured on the source server:\n\n";
        print "HOSTNAME - IP\n";
        print "-------------\n";
    }
    for my $ip ( sort keys %{$dns_cluster_href} ) {
        print $dns_cluster_href->{$ip}->{'host'} . " - " . $ip . "\n";
    }
    return;
}

sub check_for_missing_scp {
    my $mysql_output = `scp 2>&1`;
    if ( !$mysql_output || !$mysql_output =~ /usage:/i ) {
        print "\n!!! WARNING !!!: 'scp' may be missing (an attempt to run 'scp' did not return 'usage:' string), which could cause remote transfers to fail!\n\n";
    }
    return;
}

sub submit_stats_info {
    return if !( $SRC_PANEL_VERSION || $DST_PANEL_VERSION );
    my ( $panelname, $panelver, $account_num, $RETURN, $status ) = (undef) x 5;
    my $submit_host = 'qs.tech.cpanel.net';

    if ($SRC_PANEL_VERSION) {
        ( $panelname, $panelver ) = split( /\s/, $SRC_PANEL_VERSION );
    }
    if ($DST_PANEL_VERSION) {
        ( $panelname, $panelver ) = split( /\s/, $DST_PANEL_VERSION );
    }

    return if !( $panelname =~ /Plesk|Ensim|DirectAdmin/ );

    my ( $panelmajor, $panelminor ) = split( /\./, $panelver );
    return if !( $panelmajor =~ /^\d+$/ );
    $panelminor = $panelminor ? $panelminor : '0';

    $account_num = $TUD_USER_NUM;

    my $submit = "panelname=" . $panelname . "&panelver=" . $panelmajor . "." . $panelminor . "&numaccount=" . $account_num;
    my $header = "GET /submit.cgi?" . $submit . " HTTP/1.1\r\nHost: " . $submit_host . "\r\n\r\n";

    print "\nSubmitting panel stats info... (" . $submit . ")\n";
    local $SIG{'ALRM'} = sub { print "Submit time-out.\n"; return (); };
    alarm 10;

    my $sock = IO::Socket::INET->new(
        PeerAddr => $submit_host,
        PeerPort => '80',
        Proto    => 'tcp',
        Timeout  => 5,
    );

    if ($sock) {
        print $sock $header;
        sysread $sock, $RETURN, 1000;
        close $sock;
    }

    alarm 0;

    $RETURN = $RETURN ? $RETURN : '';

    for ( split /\n/, $RETURN ) {
        tr/\r//d;
        tr/\n//d;
        if (m{^HTTP/[^ ]+ (2\d\d.*)$}) {
            $status = 'Submission successful (' . $1 . ')';
            last;
        }
        if (m{^HTTP/[^ ]+ (401.*)$}) {
            $status = 'Submission is a duplicate (' . $1 . '). This is OK.';
            last;
        }
        if (m{^HTTP/[^ ]+ (400.*)$}) {
            $status = BOLD RED ON_BLACK 'WARNING: Submission attempt failed (' . $1 . '). Please contact miglead@cpanel.net with this ticket ID and paste the stats info found above into the ticket notes.';
            last;
        }
        if (m{^HTTP/[^ ]+ (.*)$}) {
            $status = BOLD RED ON_BLACK 'WARNING: Submission returned unknown status (' . $1 . '). Please contact miglead@cpanel.net with this ticket ID and paste the stats info found above into the ticket notes.';
            last;
        }
    }
    $status = $status ? $status : BOLD RED ON_BLACK 'WARNING: Submission did not return any status code!  Blocked by firewall?  Is our server down?!  We want these stats!  Please contact miglead@cpanel.net with this ticket ID and paste the stats info found above into the ticket notes.';
    print $status. "\n";
    return;
}

sub get_ticket {
    return $OPTS->{'cpmigticket'} if defined( $OPTS->{'cpmigticket'} );
    my $ticket_number_regex = qr/\d{7,10}/;
    my $ticket;
    if ( exists $ENV{HISTFILE} && $ENV{HISTFILE} =~ / ticket \D (${ticket_number_regex}) \Z /ixms ) {
        $ticket = $1;
        print "Detected ticket number " . $ticket . "\n";
    }
    if ( not $ticket or $ticket !~ / \A ${ticket_number_regex} \Z /x ) {
        print "Unable to auto-detect valid migration ticket number, please enter a valid ticket number (7 to 10 digits) or leave blank to skip: ";
        $ticket = <>;
        chomp $ticket if defined $ticket;
        if ( defined $ticket && $ticket =~ / \A ${ticket_number_regex} \Z /x ) {
            return $ticket;
        }
        else {
            print "Ticket number is not 7-10 digits.  Skipping.\n";
            return 0;
        }
    }
    return $ticket;
}

sub check_for_hacked_server_touchfile {
    my $docdir = '/usr/share/doc';
    return if !-d $docdir;

    opendir( my $fh, $docdir ) or return;

    # .cp.jeff.2014-04-09_10.5.40.209_1234567
    my @touchfiles = grep { /^\.cp\.([^\d]+)\.(\d{4}-\d{2}-\d{2})_([^_]+)_(\d+)$/ } readdir $fh;
    closedir $fh;

    return 1 if scalar @touchfiles > 0;
    return;
}

sub auto_create_keypair {
    my ( $user, $ticket ) = @_;
    return unless $IS_CPANEL_DEST;
    return if !$user;
    return if !$ticket;
    my $privkey_file = "/root/.ssh/id_" . $user;
    my $pubkey_file  = $privkey_file . ".pub";
    my $create_key   = 0;
    if ( !-f $privkey_file ) {
        $create_key = 1;
    }
    if ( !-f $pubkey_file ) {
        $create_key = 1;
    }
    if ( check_for_hacked_server_touchfile() ) {
        print "\nHacked server touch-file found, NOT auto-creating SSH keypair for migration.\n";
        return;
    }
    else {
        if ($create_key) {
            create_cpmig_keypair( $user, $ticket );
        }
        else {
            print "\nExisting cpmig SSH key pair detected at " . $privkey_file . "\n";
        }
    }
    return;
}

sub create_cpmig_keypair {
    my ( $user, $ticket ) = @_;
    return if !$user;
    return if !$ticket;
    print "\n";
    my $privkey_file = "/root/.ssh/id_" . $user;
    my $pubkey_file  = $privkey_file . ".pub";
    my $create_key   = 0;
    if ( !-f $privkey_file ) {
        $create_key = 1;
    }
    if ( !-f $pubkey_file ) {
        $create_key = 1;
    }
    if ($create_key) {
        print "-- Attempting to add a new SSH key pair at " . $privkey_file . "\n";
        if ( system( "ssh-keygen", "-q", "-t", "rsa", "-N", "", "-C", "cPanel migration services ticket " . $ticket, "-f", $privkey_file ) >= 1 ) {
            print "-- Failed to add SSH key pair. Consult any errors above for potential reasons for this.\n";
            return;
        }
    }
    my $pubkey;
    if ( open my $pubkey_fh, '<', $pubkey_file ) {
        while (<$pubkey_fh>) {
            if (/^(ssh.*${ticket})$/) {
                $pubkey = $1;
            }
        }
        close $pubkey_fh;
        if ($pubkey) {
            print "-- SSH public key found at: " . $pubkey_file . "\n";
            print "-- Copy/paste the entire command below on the SOURCE server to create a cpmig user and authorize the SSH key for login:\n";

            # This used the gzipped, base64-encoded contents of createuser.pl
            # export CPUSER="${user}" CPTICKET="${ticket}" PUBKEY="${pubkey}"; cat << END_OF_CREATEUSER | tr -d '\\\\\\n' | base64 -d | gzip -d | perl
            print << "END_OF_COMMAND";
#### BEGIN COPY BELOW ####
curl -s https://ssp.cpanel.net/cpeval/cpeval2 | perl - --create-user --cpmiguser="${user}" --cpmigticket="${ticket}" --cpmigkey="${pubkey}"
#### END COPY ABOVE ####
END_OF_COMMAND
        }
        else {
            print "-- SSH public key found at " . $pubkey_file . " but it does not appear to contain the ticket key I am looking for.  Check the contents, remove both ticket key files if necessary, and run this again.\n";
            return;
        }
    }
    print "-- Unable to open " . $pubkey_file . "\n";
    return;
}

sub create_cpmig_user {
    print "\n";

    my $fail = 0;
    foreach my $test (qw( cpmigticket cpmiguser cpmigkey )) {
        if ( !exists( $OPTS->{$test} ) || ( exists( $OPTS->{$test} ) && !$OPTS->{$test} ) ) {
            print "-- Missing " . $test . "\n";
            $fail = 1;
        }
    }

    die if $fail;

    my $user   = $OPTS->{'cpmiguser'};
    my $ticket = $OPTS->{'cpmigticket'};
    my $pubkey = $OPTS->{'cpmigkey'};
    my $password;
    my $expire;
    my @user_pwent;

    if ( @user_pwent = getpwnam($user) ) {
        print "-- Found existing " . $user . " account\n";
    }
    else {
        $expire = strftime "%Y-%m-%d", localtime( time + ( 86400 * 60 ) );    # Expire 60 days from now
        print "-- Attempting to add account for " . $user . " which will expire on " . $expire . ":\n";
        system( "useradd", "-c", "cPanel migration services ticket " . $ticket, "-e", $expire, "-m", $user );
        if ( @user_pwent = getpwnam($user) ) {
            print "-- Success!\n";
        }
        else {
            die "Failed to add account. Consult any errors from 'useradd' above for potential reasons for this.\n";
        }
        print "-- Attempting to add " . $user . " to wheel group (might fail on some systems).\n";
        system( "usermod", "-G", "wheel", $user );
        print "-- Attempting to set random password for " . $user . ":\n";
        $password = join( '', map { +( 0 .. 9, 'a' .. 'z', 'A' .. 'Z' )[ rand( 10 + 26 * 2 ) ] } 1 .. 16 );
        if ( open( my $chpasswd_fh, '|-', 'chpasswd' ) ) {
            print $chpasswd_fh $user . ':' . $password . "\n";
            close $chpasswd_fh;
        }
        else {
            die "Failed to execute chpasswd to set password.\n";
        }
    }

    if ( open my $passwd_fh, '-|', "passwd -S ${user}" ) {
        my $password_set = 0;
        while (<$passwd_fh>) {
            if ( m{ \A ${user} \s P.? \s }x || m{ \A Password \s set }x ) {
                $password_set = 1;
                print "-- Password is set.\n";
            }
        }
        close $passwd_fh;
        die "Password check failed, \"passwd -S " . $user . "\" does not report that password is set.\n" unless $password_set;
    }
    else {
        die "Failed to execute \"passwd -S " . $user . "\" to check password status.\n";
    }

    my $homedir = $user_pwent[7];
    die "Unable to look up homedir for " . $user . "\n" unless $homedir;
    die "Home directory for " . $user . " does not exist\n" unless -d $homedir;

    my $sshdir = $homedir . "/.ssh";

    if ( !-d $sshdir ) {
        mkdir $sshdir, 0700;
    }

    die ".ssh directory for " . $user . " could not be created\n" unless -d $sshdir;

    chown $user_pwent[2], $user_pwent[3], $sshdir;
    chmod 0700, $sshdir;

    my $authkeys_file = $sshdir . "/authorized_keys";
    my $have_key      = 0;

    if ( open my $authkeys_fh, "<", $authkeys_file ) {
        while (<$authkeys_fh>) {
            if (/^\Q$pubkey\E$/) {
                $have_key = 1;
            }
        }
        close $authkeys_fh;
        if ($have_key) {
            print "-- SSH key already found in " . $authkeys_file . "\n";
            $have_key = 1;
        }
    }

    if ( !$have_key ) {
        if ( open my $authkeys_fh, ">>", $authkeys_file ) {
            print $authkeys_fh $pubkey . "\n";
            close $authkeys_fh;
        }
        if ( open my $authkeys_fh, "<", $authkeys_file ) {
            while (<$authkeys_fh>) {
                if (/\Q$pubkey\E$/) {
                    $have_key = 1;
                }
            }
            close $authkeys_fh;
            if ($have_key) {
                print "-- SSH key successfully added to " . $authkeys_file . "\n";
            }
            else {
                die "Failed to add SSH key to " . $authkeys_file . "\n";
            }
        }
    }

    chown $user_pwent[2], $user_pwent[3], $authkeys_file;
    chmod 0600, $authkeys_file;

    my $sudoers_include_file = "/etc/sudoers.d/cp_migration_" . $ticket;
    my $sudo_entry           = $user . "\tALL=(ALL)\tALL";
    my $have_sudo            = 0;

    if ( open my $sudoers_fh, "<", $sudoers_include_file ) {
        while (<$sudoers_fh>) {
            if (/^\Q$sudo_entry\E$/) {
                $have_sudo = 1;
            }
        }
        if ($have_sudo) {
            print "-- Sudo user entry already found in " . $sudoers_include_file . "\n";
        }
        close $sudoers_fh;
    }

    if ( !$have_sudo ) {
        if ( open my $sudoers_fh, ">>", $sudoers_include_file ) {
            print $sudoers_fh $sudo_entry . "\n";
            close $sudoers_fh;
        }
        if ( open my $sudoers_fh, "<", $sudoers_include_file ) {
            while (<$sudoers_fh>) {
                if (/^\Q$sudo_entry\E$/) {
                    $have_sudo = 1;
                }
            }
            close $sudoers_fh;
            if ($have_sudo) {
                print "-- Added sudo entry to " . $sudoers_include_file . "\n";
            }
            else {
                die "-- Failed to add sudo entry to " . $sudoers_include_file . "\n";
            }
        }
    }

    my $sudoers_main_file = "/etc/sudoers";
    my $have_include      = 0;

    if ( open my $sudoers_fh, "<", $sudoers_main_file ) {
        while (<$sudoers_fh>) {
            if (m{^#includedir\s+/etc/sudoers\.d$}) {
                $have_include = 1;
            }
        }
        if ( !$have_include ) {
            print "!! WARNING: \"#includedir /etc/sudoers.d\" not found in " . $sudoers_main_file . ", this means a sudo entry will need to be manually added to /etc/sudoers for " . $user . ":\n" . $sudo_entry . "\n";
        }
        close $sudoers_fh;
    }

    if ( $password && $expire ) {
        print "-- Copy the following information to the Server Information box in the migration ticket:\n";
        print "#### BEGIN COPY BELOW ####\n";
        print "Migration User Name: " . $user . "\n";
        print "Migration User Password: " . $password . "\n";
        print "Migration User Expiration: " . $expire . "\n";
        print "Migration Ticket Number: " . $ticket . "\n";
        print "#### END COPY ABOVE ####\n";
    }
    else {
        print "-- A new user was not created this time, so there is no password info to give.\n";
    }

    exit 0;
}

sub opts_get {
    my $badopt = 0;
    my %opts   = (
        'cpanelsource'      => 0,
        'createkeys'        => 0,
        'createuser'        => 0,
        'cpmigticket'       => undef,
        'cpmiguser'         => undef,
        'cpmigkey'          => undef,
        'es'                => 0,
        'help'              => 0,
        'inputfile'         => undef,
        'full-help'         => 0,
        'updateuserdomains' => 0
    );

    Getopt::Long::GetOptions(
        'cpanel-source|cpanelsource' => \$opts{'cpanelsource'},
        'create-keys|createkeys'     => \$opts{'createkeys'},
        'create-user|createuser'     => \$opts{'createuser'},
        'cpmigticket=i'              => \$opts{'cpmigticket'},
        'cpmiguser=s'                => \$opts{'cpmiguser'},
        'cpmigkey=s'                 => \$opts{'cpmigkey'},
        'debug'                      => \$DEBUG,
        'es'                         => \$opts{'es'},
        'full-help|fullhelp'         => \$opts{'full-help'},
        'inputfile=s'                => \$opts{'inputfile'},
        'updateuserdomains'          => \$opts{'updateuserdomains'},
        'usage|help|h'               => \$opts{'help'}
    ) or $badopt = 1;

    $opts{'inputfile'} = shift @ARGV unless defined( $opts{'inputfile'} );

    open my $pod_fh, '<', \$pod_data or die "I'm missing my internal documentation\n";

    pod2usage( { -exitval => 1, -verbose => 1, -input => $pod_fh } ) if $opts{'help'};
    pod2usage( { -exitval => 1, -verbose => 2, -input => $pod_fh } ) if $opts{'full-help'};
    pod2usage( { -exitval => 2, -verbose => 1, -input => $pod_fh } ) if $badopt;

    if ( @ARGV > 1 ) {
        print STDERR "Too many input file names specified on command line.\n";
        pod2usage( { -exitval => 2, -verbose => 1, -input => $pod_fh } );
    }

    if ( defined( $opts{'inputfile'} ) && !-f $opts{'inputfile'} ) {
        print STDERR "Input file does not exist.\n";
        pod2usage( { -exitval => 2, -verbose => 1, -input => $pod_fh } );
    }

    close $pod_fh;

    return \%opts;
}
